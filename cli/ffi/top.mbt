// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
///|
pub extern "wasm" fn extend16(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend16_s)

///|
pub extern "wasm" fn extend8(value : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.extend8_s)

///|
pub extern "wasm" fn store8(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store8)

///|
pub extern "wasm" fn load8_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_u)

///|
pub extern "wasm" fn load8(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load8_s)

///|
pub extern "wasm" fn store16(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store16)

///|
pub extern "wasm" fn load16(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_s)

///|
pub extern "wasm" fn load16_u(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load16_u)

///|
pub extern "wasm" fn store32(offset : Int, value : Int) =
  #|(func (param i32) (param i32) local.get 0 local.get 1 i32.store)

///|
pub extern "wasm" fn load32(offset : Int) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.load)

///|
pub extern "wasm" fn store64(offset : Int, value : Int64) =
  #|(func (param i32) (param i64) local.get 0 local.get 1 i64.store)

///|
pub extern "wasm" fn load64(offset : Int) -> Int64 =
  #|(func (param i32) (result i64) local.get 0 i64.load)

///|
pub extern "wasm" fn storef32(offset : Int, value : Float) =
  #|(func (param i32) (param f32) local.get 0 local.get 1 f32.store)

///|
pub extern "wasm" fn loadf32(offset : Int) -> Float =
  #|(func (param i32) (result f32) local.get 0 f32.load)

///|
pub extern "wasm" fn storef64(offset : Int, value : Double) =
  #|(func (param i32) (param f64) local.get 0 local.get 1 f64.store)

///|
pub extern "wasm" fn loadf64(offset : Int) -> Double =
  #|(func (param i32) (result f64) local.get 0 f64.load)

///|
pub extern "wasm" fn f32_to_i32(value : Float) -> Int =
  #|(func (param f32) (result i32) local.get 0 f32.convert_i32_s)

///|
pub extern "wasm" fn f32_to_i64(value : Float) -> Int64 =
  #|(func (param f32) (result i64) local.get 0 f32.convert_i64_s)

// set pseudo header; allocate extra bytes for string

///|
pub extern "wasm" fn malloc(size : Int) -> Int =
  #|(func (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 4 i32.add call $moonbit.gc.malloc
  #| local.tee 1 i32.const 0 call $moonbit.init_array8
  #| local.get 1 i32.const 8 i32.add)

///|
pub extern "wasm" fn free(position : Int) =
  #|(func (param i32) local.get 0 i32.const 8 i32.sub call $moonbit.decref)

///|
extern "wasm" fn copy(dest : Int, src : Int, len : Int) =
  #|(func (param i32) (param i32) (param i32) local.get 0 local.get 1 local.get 2 memory.copy)

///|
pub extern "wasm" fn str2ptr(str : String) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn ptr2str(ptr : Int, len : Int) -> String =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array16
  #| local.get 2)

///|
pub extern "wasm" fn bytes2ptr(bytes : FixedArray[Byte]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn ptr2bytes(ptr : Int, len : Int) -> FixedArray[Byte] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array8
  #| local.get 2)

///|
pub extern "wasm" fn uint_array2ptr(array : FixedArray[UInt]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn uint64_array2ptr(array : FixedArray[UInt64]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn int_array2ptr(array : FixedArray[Int]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn int64_array2ptr(array : FixedArray[Int64]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn float_array2ptr(array : FixedArray[Float]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn double_array2ptr(array : FixedArray[Double]) -> Int =
  #|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

///|
pub extern "wasm" fn ptr2uint_array(ptr : Int, len : Int) -> FixedArray[UInt] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array32
  #| local.get 2)

///|
pub extern "wasm" fn ptr2int_array(ptr : Int, len : Int) -> FixedArray[Int] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array32
  #| local.get 2)

///|
pub extern "wasm" fn ptr2float_array(ptr : Int, len : Int) -> FixedArray[Float] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array32
  #| local.get 2)

///|
pub extern "wasm" fn ptr2uint64_array(
  ptr : Int,
  len : Int,
) -> FixedArray[UInt64] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array64
  #| local.get 2)

///|
pub extern "wasm" fn ptr2int64_array(ptr : Int, len : Int) -> FixedArray[Int64] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array64
  #| local.get 2)

///|
pub extern "wasm" fn ptr2double_array(
  ptr : Int,
  len : Int,
) -> FixedArray[Double] =
  #|(func (param i32) (param i32) (result i32) (local i32)
  #| local.get 0 i32.const 8 i32.sub local.tee 2
  #| local.get 1 call $moonbit.init_array64
  #| local.get 2)

///|
pub fn cabi_realloc(
  src_offset : Int,
  src_size : Int,
  _dst_alignment : Int,
  dst_size : Int,
) -> Int {
  // malloc
  if src_offset == 0 && src_size == 0 {
    return malloc(dst_size)
  }
  // free
  if dst_size == 0 {
    free(src_offset)
    return 0
  }
  // realloc
  let dst = malloc(dst_size)
  copy(dst, src_offset, if src_size < dst_size { src_size } else { dst_size })
  free(src_offset)
  dst
}

///|
pub(open) trait Any {}

///|
pub(all) struct Cleanup {
  address : Int
  size : Int
  align : Int
}

///|
async fn[T, E : Error] async_suspend(
  cb : ((T) -> Unit, (E) -> Unit) -> Unit,
) -> T raise E = "%async.suspend"

///|
fn run_async(f : async () -> Unit noraise) = "%async.run"

///|
priv enum State {
  Done
  Fail(Error)
  Running
  Suspend(ok_cont~ : (Unit) -> Unit, err_cont~ : (Error) -> Unit)
}

///|
struct Coroutine {
  coro_id : Int
  mut state : State
  mut shielded : Bool
  mut cancelled : Bool
  mut ready : Bool
  downstream : Map[Int, Coroutine]
}

///|
pub impl Eq for Coroutine with equal(c1, c2) {
  c1.coro_id == c2.coro_id
}

///|
pub impl Hash for Coroutine with hash_combine(self, hasher) {
  self.coro_id.hash_combine(hasher)
}

///|
pub fn Coroutine::wake(self : Coroutine) -> Unit {
  self.ready = true
  scheduler.run_later.push_back(self)
}

///|
pub fn Coroutine::run(self : Coroutine) -> Unit {
  self.ready = true
  scheduler.run_later.push_front(self)
}

///|
pub fn Coroutine::is_done(self : Coroutine) -> Bool {
  match self.state {
    Done => true
    Fail(_) => true
    Running | Suspend(_) => false
  }
}

///|
pub fn is_being_cancelled() -> Bool {
  current_coroutine().cancelled
}

///|
pub fn current_coroutine_done() -> Bool {
  guard scheduler.curr_coro is Some(coro) else { return true }
  coro.is_done()
}

///|
pub(all) suberror Cancelled derive(Show)

///|
pub fn Coroutine::cancel(self : Coroutine) -> Unit {
  self.cancelled = true
  if not(self.shielded || self.ready) {
    self.wake()
  }
}

///|
pub async fn pause() -> Unit {
  guard scheduler.curr_coro is Some(coro)
  if coro.cancelled && not(coro.shielded) {
    raise Cancelled::Cancelled
  }
  async_suspend(fn(ok_cont, err_cont) {
    guard coro.state is Running
    coro.state = Suspend(ok_cont~, err_cont~)
    coro.ready = true
    scheduler.run_later.push_back(coro)
  })
}

///|
pub async fn suspend() -> Unit {
  guard scheduler.curr_coro is Some(coro)
  if coro.cancelled && not(coro.shielded) {
    raise Cancelled::Cancelled
  }
  scheduler.blocking += 1
  defer {
    scheduler.blocking -= 1
  }
  async_suspend(fn(ok_cont, err_cont) {
    guard coro.state is Running
    coro.state = Suspend(ok_cont~, err_cont~)
  })
}

///|
pub fn spawn(f : async () -> Unit) -> Coroutine {
  scheduler.coro_id += 1
  let coro = {
    state: Running,
    ready: true,
    shielded: false,
    downstream: {},
    coro_id: scheduler.coro_id,
    cancelled: false,
  }
  fn run(_) {
    run_async(fn() {
      coro.shielded = false
      try f() catch {
        err => coro.state = Fail(err)
      } noraise {
        _ => coro.state = Done
      }
      for _, coro in coro.downstream {
        coro.wake()
      }
      coro.downstream.clear()
    })
  }

  coro.state = Suspend(ok_cont=run, err_cont=_ => ())
  scheduler.run_later.push_back(coro)
  coro
}

///|
pub fn Coroutine::unwrap(self : Coroutine) -> Unit raise {
  match self.state {
    Done => ()
    Fail(err) => raise err
    Running | Suspend(_) => panic()
  }
}

///|
pub async fn Coroutine::wait(target : Coroutine) -> Unit {
  guard scheduler.curr_coro is Some(coro)
  guard not(physical_equal(coro, target))
  match target.state {
    Done => return
    Fail(err) => raise err
    Running | Suspend(_) => ()
  }
  target.downstream[coro.coro_id] = coro
  try suspend() catch {
    err => {
      target.downstream.remove(coro.coro_id)
      raise err
    }
  } noraise {
    _ => target.unwrap()
  }
}

///|
pub async fn protect_from_cancel(f : async () -> Unit) -> Unit {
  guard scheduler.curr_coro is Some(coro)
  if coro.shielded {
    // already in a shield, do nothing
    f()
  } else {
    coro.shielded = true
    defer {
      coro.shielded = false
    }
    f()
    if coro.cancelled {
      raise Cancelled::Cancelled
    }
  }
}

///|
priv struct Scheduler {
  mut coro_id : Int
  mut curr_coro : Coroutine?
  mut blocking : Int
  run_later : @deque.Deque[Coroutine]
}

///|
let scheduler : Scheduler = {
  coro_id: 0,
  curr_coro: None,
  blocking: 0,
  run_later: @deque.new(),
}

///|
pub fn current_coroutine() -> Coroutine {
  scheduler.curr_coro.unwrap()
}

///|
pub fn no_more_work() -> Bool {
  scheduler.blocking == 0 && scheduler.run_later.is_empty()
}

///|
pub fn rschedule() -> Unit {
  while scheduler.run_later.pop_front() is Some(coro) {
    coro.ready = false
    guard coro.state is Suspend(ok_cont~, err_cont~) else {  }
    coro.state = Running
    let last_coro = scheduler.curr_coro
    scheduler.curr_coro = Some(coro)
    if coro.cancelled && !coro.shielded {
      err_cont(Cancelled::Cancelled)
    } else {
      ok_cont(())
    }
    scheduler.curr_coro = last_coro
  }
}

///|
pub struct FutureVTable[T] {
  new : () -> UInt64
  read : (Int, Int) -> Int
  write : (Int, Int) -> Int
  cancel_read : (Int) -> Int
  cancel_write : (Int) -> Int
  drop_readable : (Int) -> Unit
  drop_writable : (Int) -> Unit
  malloc : (Int) -> Int
  free : (Int) -> Unit
  lift : (Int) -> T
  lower : (T, Int) -> Unit
}

///|
pub fn[T] FutureVTable::new(
  new : () -> UInt64,
  read : (Int, Int) -> Int,
  write : (Int, Int) -> Int,
  cancel_read : (Int) -> Int,
  cancel_write : (Int) -> Int,
  drop_readable : (Int) -> Unit,
  drop_writable : (Int) -> Unit,
  malloc : (Int) -> Int,
  free : (Int) -> Unit,
  lift : (Int) -> T,
  lower : (T, Int) -> Unit,
) -> FutureVTable[T] {
  {
    new,
    read,
    write,
    cancel_read,
    cancel_write,
    drop_readable,
    drop_writable,
    malloc,
    free,
    lift,
    lower,
  }
}

///|
pub fn[T] new_future(
  vtable : FutureVTable[T],
) -> (FutureReader[T], FutureWriter[T]) {
  let handle = (vtable.new)()
  let left_handle = handle.to_int()
  let right_handle = (handle >> 32).to_int()
  (
    FutureReader::new(left_handle, vtable),
    FutureWriter::new(right_handle, vtable),
  )
}

///|
pub struct FutureReader[T] {
  handle : Int
  vtable : FutureVTable[T]
  mut code : Int?
  mut dropped : Bool
  memory_refs : Array[Int]
}

///|
pub fn[T] FutureReader::new(
  handle : Int,
  vtable : FutureVTable[T],
) -> FutureReader[T] {
  { handle, vtable, code: None, memory_refs: [], dropped: false }
}

///|
pub impl[T] Waitable for FutureReader[T] with update(self, code~ : Int) -> Unit {
  self.code = Some(code)
}

///|
pub impl[T] Eq for FutureReader[T] with equal(self, other) -> Bool {
  self.handle == other.handle
}

///|
pub impl[T] Waitable for FutureReader[T] with handle(self) -> Int {
  self.handle
}

///|
pub impl[T] Waitable for FutureReader[T] with cancel(self) -> Unit {
  if self.code is Some(code) && WaitableStatus::decode(code) is Cancelled(_) {
    return
  }
  self.code = Some((self.vtable.cancel_read)(self.handle))
}

///|
pub impl[T] Waitable for FutureReader[T] with drop(self) -> Bool {
  _async_debug("stream-reader-drop(\{self.handle})")
  if self.dropped {
    return false
  }
  (self.vtable.drop_readable)(self.handle)
  self.dropped = true
  for ptr in self.memory_refs {
    self.free(ptr)
  }
  true
}

///|
pub impl[T] Waitable for FutureReader[T] with done(self) -> Bool {
  match self.code {
    Some(c) =>
      match WaitableStatus::decode(c) {
        Completed(_) | Dropped(_) | Cancelled(_) => true
        Blocking => false
      }
    None => false
  }
}

///|
pub fn[T] FutureReader::malloc(self : FutureReader[T]) -> Int {
  let ptr = (self.vtable.malloc)(1)
  ptr
}

///|
pub fn[T] FutureReader::free(self : FutureReader[T], ptr : Int) -> Unit {
  (self.vtable.free)(ptr)
}

///|
pub fn[T] FutureReader::lift(self : FutureReader[T], ptr : Int) -> T {
  let res = (self.vtable.lift)(ptr)
  res
}

///|
pub fn[T] FutureReader::lower_read(self : FutureReader[T], ptr : Int) -> Int {
  (self.vtable.read)(self.handle, ptr)
}

///|
pub async fn[T] FutureReader::read(self : FutureReader[T]) -> T {
  let buf_ptr = self.malloc()
  self.memory_refs.push(buf_ptr)
  self.code = Some(self.lower_read(buf_ptr))
  _async_debug("future-read(\{self.handle}) -> \{self.code.unwrap()}")
  // register this waitable to the current task
  let task = current_task()
  task.add_waitable(self, current_coroutine())
  defer task.remove_waitable(self)

  // wait until ready
  for {
    let status = WaitableStatus::decode(self.code.unwrap())
    match status {
      Cancelled(_) | Dropped(_) => raise Cancelled::Cancelled
      Completed(_) => break
      Blocking => suspend()
    }
  }
  // when receive event, continue this coroutine
  let value = self.lift(buf_ptr)
  return value
}

///|
pub struct FutureWriter[T] {
  handle : Int
  vtable : FutureVTable[T]
  mut code : Int?
  mut dropped : Bool
  memory_refs : Array[Int]
}

///|
pub fn[T] FutureWriter::new(
  handle : Int,
  vtable : FutureVTable[T],
) -> FutureWriter[T] {
  { handle, vtable, code: None, memory_refs: [], dropped: false }
}

///|
pub impl[T] Waitable for FutureWriter[T] with update(self, code~ : Int) -> Unit {
  self.code = Some(code)
}

///|
pub impl[T] Eq for FutureWriter[T] with equal(self, other) -> Bool {
  self.handle == other.handle
}

///|
pub impl[T] Waitable for FutureWriter[T] with handle(self) -> Int {
  self.handle
}

///|
pub impl[T] Waitable for FutureWriter[T] with cancel(self) -> Unit {
  if self.code is Some(code) && WaitableStatus::decode(code) is Cancelled(_) {
    return
  }
  self.code = Some((self.vtable.cancel_write)(self.handle))
}

///|
pub impl[T] Waitable for FutureWriter[T] with drop(self) -> Bool {
  _async_debug("stream-writer-drop(\{self.handle})")
  if self.dropped {
    return false
  }
  (self.vtable.drop_writable)(self.handle)
  self.dropped = true
  for ptr in self.memory_refs {
    self.free(ptr)
  }
  true
}

///|
pub impl[T] Waitable for FutureWriter[T] with done(self) -> Bool {
  match self.code {
    Some(c) =>
      match WaitableStatus::decode(c) {
        Completed(_) | Dropped(_) | Cancelled(_) => true
        Blocking => false
      }
    None => false
  }
}

///|
pub fn[T] FutureWriter::malloc(self : FutureWriter[T]) -> Int {
  (self.vtable.malloc)(1)
}

///|
pub fn[T] FutureWriter::free(self : FutureWriter[T], ptr : Int) -> Unit {
  (self.vtable.free)(ptr)
}

///|
pub fn[T] FutureWriter::lower(
  self : FutureWriter[T],
  value : T,
  ptr : Int,
) -> Unit {
  (self.vtable.lower)(value, ptr)
}

///|
pub fn[T] FutureWriter::lower_write(self : FutureWriter[T], ptr : Int) -> Int {
  (self.vtable.write)(self.handle, ptr)
}

///|
pub async fn[T] FutureWriter::write(self : FutureWriter[T], value : T) -> Unit {
  // register this waitable to the current task
  let task = current_task()
  task.add_waitable(self, current_coroutine())
  defer task.remove_waitable(self)
  let buf_ptr = self.malloc()
  self.memory_refs.push(buf_ptr)
  self.lower(value, buf_ptr)
  self.code = Some(self.lower_write(buf_ptr))
  defer self.free(buf_ptr)

  // wait until ready
  for {
    let status = WaitableStatus::decode(self.code.unwrap())
    match status {
      Cancelled(_) | Dropped(_) => raise Cancelled::Cancelled
      Completed(_) => break
      Blocking => suspend()
    }
  }
  // when receive event, continue this coroutine
  return
}

///|
pub suberror StreamCancelled (Int, Cancelled) derive(Show)

///|
pub struct StreamVTable[T] {
  new : () -> UInt64
  read : (Int, Int, Int) -> Int
  write : (Int, Int, Int) -> Int
  cancel_read : (Int) -> Int
  cancel_write : (Int) -> Int
  drop_readable : (Int) -> Unit
  drop_writable : (Int) -> Unit
  malloc : (Int) -> Int
  free : (Int) -> Unit
  lift : (Int, Int) -> FixedArray[T]
  lower : (FixedArray[T]) -> Int
}

///|
pub fn[T] StreamVTable::new(
  new : () -> UInt64,
  read : (Int, Int, Int) -> Int,
  write : (Int, Int, Int) -> Int,
  cancel_read : (Int) -> Int,
  cancel_write : (Int) -> Int,
  drop_readable : (Int) -> Unit,
  drop_writable : (Int) -> Unit,
  malloc : (Int) -> Int,
  free : (Int) -> Unit,
  lift : (Int, Int) -> FixedArray[T],
  lower : (FixedArray[T]) -> Int,
) -> StreamVTable[T] {
  {
    new,
    read,
    write,
    cancel_read,
    cancel_write,
    drop_readable,
    drop_writable,
    malloc,
    free,
    lift,
    lower,
  }
}

///|
pub fn[T] new_stream(
  vtable : StreamVTable[T],
) -> (StreamReader[T], StreamWriter[T]) {
  let handle = (vtable.new)()
  let left_handle = handle.to_int()
  let right_handle = (handle >> 32).to_int()
  (
    StreamReader::new(left_handle, vtable),
    StreamWriter::new(right_handle, vtable),
  )
}

///|
pub struct StreamReader[T] {
  handle : Int
  vtable : StreamVTable[T]
  mut code : Int?
  mut dropped : Bool
  memory_refs : Array[Int]
}

///|
pub impl[T] Waitable for StreamReader[T] with update(self, code~ : Int) -> Unit {
  self.code = Some(code)
}

///|
pub impl[T] Eq for StreamReader[T] with equal(self, other) -> Bool {
  self.handle == other.handle
}

///|
pub impl[T] Waitable for StreamReader[T] with handle(self) -> Int {
  self.handle
}

///|
pub impl[T] Waitable for StreamReader[T] with cancel(self) -> Unit {
  if self.code is Some(code) && WaitableStatus::decode(code) is Cancelled(_) {
    return
  }
  self.code = Some((self.vtable.cancel_read)(self.handle))
}

///|
pub impl[T] Waitable for StreamReader[T] with drop(self) -> Bool {
  _async_debug("stream-reader-drop(\{self.handle})")
  if self.dropped {
    return false
  }
  (self.vtable.drop_readable)(self.handle)
  self.dropped = true
  for ptr in self.memory_refs {
    (self.vtable.free)(ptr)
  }
  true
}

///|
pub impl[T] Waitable for StreamReader[T] with done(self) -> Bool {
  match self.code {
    Some(c) =>
      match WaitableStatus::decode(c) {
        Completed(_) | Dropped(_) | Cancelled(_) => true
        Blocking => false
      }
    None => false
  }
}

///|
pub fn[T] StreamReader::new(
  handle : Int,
  vtable : StreamVTable[T],
) -> StreamReader[T] {
  { handle, vtable, code: None, memory_refs: [], dropped: false }
}

///|
pub async fn[T] StreamReader::read(
  self : StreamReader[T],
  buffer : FixedArray[T],
  offset? : Int = 0,
  length : Int,
) -> Int {
  // register this waitable to the current task
  let task = current_task()
  task.add_waitable(self, current_coroutine())
  defer task.remove_waitable(self)
  let buf_ptr = (self.vtable.malloc)(length)
  self.code = Some((self.vtable.read)(self.handle, buf_ptr, length))
  _async_debug("stream-read(\{self.handle}) -> \{self.code.unwrap()}")
  for {
    let status = WaitableStatus::decode(self.code.unwrap())
    match status {
      Completed(n) => {
        let read_result = (self.vtable.lift)(buf_ptr, n)
        for i in 0..<n {
          buffer[offset + i] = read_result[i]
        }
        return n
      }
      Cancelled(n) | Dropped(n) => {
        let read_result = (self.vtable.lift)(buf_ptr, n)
        for i in 0..<n {
          buffer[offset + i] = read_result[i]
        }
        raise StreamCancelled::StreamCancelled((n, Cancelled::Cancelled))
      }
      Blocking => suspend()
    }
  }
}

///|
pub struct StreamWriter[T] {
  handle : Int
  vtable : StreamVTable[T]
  mut code : Int?
  mut dropped : Bool
  memory_refs : Array[Int]
}

///|
pub impl[T] Waitable for StreamWriter[T] with update(self, code~ : Int) -> Unit {
  self.code = Some(code)
}

///|
pub impl[T] Eq for StreamWriter[T] with equal(self, other) -> Bool {
  self.handle == other.handle
}

///|
pub impl[T] Waitable for StreamWriter[T] with handle(self) -> Int {
  self.handle
}

///|
pub impl[T] Waitable for StreamWriter[T] with cancel(self) -> Unit {
  if self.code is Some(code) && WaitableStatus::decode(code) is Cancelled(_) {
    return
  }
  self.code = Some((self.vtable.cancel_write)(self.handle))
}

///|
pub impl[T] Waitable for StreamWriter[T] with drop(self) -> Bool {
  _async_debug("stream-writer-drop(\{self.handle})")
  let task = current_task()
  let coro = task.children.get(self.handle)
  if coro is Some((_, coro)) {
    coro.cancel()
    coro.wake()
  }
  if self.dropped {
    return false
  }
  (self.vtable.drop_writable)(self.handle)
  self.dropped = true
  for ptr in self.memory_refs {
    (self.vtable.free)(ptr)
  }
  true
}

///|
pub impl[T] Waitable for StreamWriter[T] with done(self) -> Bool {
  match self.code {
    Some(c) =>
      match WaitableStatus::decode(c) {
        Completed(_) | Dropped(_) | Cancelled(_) => true
        Blocking => false
      }
    None => false
  }
}

///|
pub fn[T] StreamWriter::new(
  handle : Int,
  vtable : StreamVTable[T],
) -> StreamWriter[T] {
  { handle, vtable, code: None, memory_refs: [], dropped: false }
}

///|
pub async fn[T] StreamWriter::write(
  self : StreamWriter[T],
  buffer : FixedArray[T],
) -> Int {
  // register this waitable to the current task
  let task = current_task()
  task.add_waitable(self, current_coroutine())
  defer task.remove_waitable(self)
  let write_buf = (self.vtable.lower)(buffer)
  self.code = Some((self.vtable.write)(self.handle, write_buf, buffer.length()))
  for {
    let status = WaitableStatus::decode(self.code.unwrap())
    match status {
      Completed(n) => return n
      Cancelled(n) | Dropped(n) =>
        raise StreamCancelled::StreamCancelled((n, Cancelled::Cancelled))
      Blocking => suspend()
    }
  }
}

///|
pub(open) trait Waitable {
  update(Self, code~ : Int) -> Unit
  cancel(Self) -> Unit

  // when the waitable is dropped, this function is called to free resources
  drop(Self) -> Bool
  done(Self) -> Bool
  handle(Self) -> Int
}

///|
pub(all) enum SubtaskStatus {
  Starting(Int)
  Started(Int)
  Returned(Int)
  StartCancelled(Int)
  ReturnCancelled(Int)
} derive(Eq, Show)

///|
pub fn SubtaskStatus::decode(int : Int) -> SubtaskStatus {
  let handle = int >> 4
  match int & 0xf {
    0 => Starting(handle)
    1 => Started(handle)
    2 => Returned(handle)
    3 => StartCancelled(handle)
    4 => ReturnCancelled(handle)
    _ => panic()
  }
}

///|
pub fn SubtaskStatus::handle(self : Self) -> Int {
  match self {
    Starting(handle) => handle
    Started(handle) => handle
    Returned(handle) => handle
    StartCancelled(handle) => handle
    ReturnCancelled(handle) => handle
  }
}

///|
pub(all) enum Event {
  None
  Subtask
  StreamRead
  StreamWrite
  FutureRead
  FutureWrite
  TaskCancel
} derive(Eq, Show)

///|
pub fn Event::decode(int : Int) -> Event {
  match int {
    0 => None
    1 => Subtask
    2 => StreamRead
    3 => StreamWrite
    4 => FutureRead
    5 => FutureWrite
    6 => TaskCancel
    _ => panic()
  }
}

///|
pub fn Event::encode(self : Self) -> Int {
  match self {
    None => 0
    Subtask => 1
    StreamRead => 2
    StreamWrite => 3
    FutureRead => 4
    FutureWrite => 5
    TaskCancel => 6
  }
}

///|
pub(all) enum WaitableStatus {
  Completed(Int)
  Dropped(Int)
  Cancelled(Int)
  Blocking
} derive(Eq, Show)

///|
let waitable_status_block : Int = 0xffff_ffff

///|
pub fn WaitableStatus::decode(int : Int) -> WaitableStatus {
  if int == waitable_status_block {
    return Blocking
  }
  let amt = int >> 4
  match int & 0xf {
    0 => Completed(amt)
    1 => Dropped(amt)
    2 => Cancelled(amt)
    _ => panic()
  }
}

///|
pub fn WaitableStatus::count(int : Int) -> Int {
  int >> 4
}

///|
pub(all) enum CallbackCode {
  Exit
  Yield
  Wait(Int)
  Cancel(Int)
} derive(Eq, Show)

///|
pub fn CallbackCode::encode(self : Self) -> Int {
  match self {
    Exit => 0
    Yield => 1
    Wait(id) => 2 | (id << 4)
    Cancel(id) => 3 | (id << 4)
  }
}

///|
pub fn CallbackCode::decode(int : Int) -> CallbackCode {
  let id = int >> 4
  match int & 0xf {
    0 => Exit
    1 => Yield
    2 => Wait(id)
    3 => Cancel(id)
    _ => panic()
  }
}

///|
/// This function is empty, If you want to print debug info, you can hook it in your environment.
pub fn _async_debug(_msg : String) -> Unit {
  print(_msg)
}

// Component async primitives

///|
pub fn yield_blocking() -> Bool = "$root" "[yield]"

///|
pub fn backpressure_set() -> Int = "$root" "[backpressure-set]"

///|
pub fn subtask_cancel(id : Int) -> Int = "$root" "[subtask-cancel]"

///|
pub fn subtask_drop(id : Int) = "$root" "[subtask-drop]"

///|
pub fn context_set(task : Int) = "$root" "[context-set-0]"

///|
pub fn context_get() -> Int = "$root" "[context-get-0]"

///|
pub fn task_cancel() = "[export]$root" "[task-cancel]"

///|
pub fn waitable_set_new() -> Int = "$root" "[waitable-set-new]"

///|
pub fn waitable_set_drop(set : Int) = "$root" "[waitable-set-drop]"

///|
pub fn waitable_join(waitable : Int, set : Int) = "$root" "[waitable-join]"

///|
pub fn waitable_set_wait(set : Int, result_ptr : Int) -> Int = "$root" "[waitable-set-wait]"

///|
pub fn waitable_set_poll(set : Int, result_ptr : Int) -> Int = "$root" "[waitable-set-poll]"

///|
priv enum TaskStatus {
  Fail(Error)
  Running
  Done
}

///|
/// A `Task` represents a waitable task context that can manage waitables and child coroutines.
///
struct Task {
  id : Int
  children : Map[Int, (&Waitable, Coroutine)]
  task_defer : Array[() -> Unit raise]
  resources : @deque.Deque[Int]
  mut task : Coroutine?
  mut waiting : Int
  mut status : TaskStatus
}

///|
pub let task_map : Map[Int, Task] = {}

///|
pub fn Task::new() -> Task {
  let waitable_set = waitable_set_new()
  _async_debug("waitable-set-new(\{waitable_set})")
  context_set(waitable_set)
  {
    id: waitable_set,
    children: {},
    resources: @deque.Deque::new(),
    task_defer: [],
    status: Running,
    waiting: 0,
    task: None,
  }
}

///|
pub fn Task::from_raw(raw : Int) -> Task {
  guard raw != 0
  context_set(raw)
  _async_debug("context-set(\{raw})")
  {
    id: raw,
    children: {},
    resources: @deque.Deque::new(),
    task_defer: [],
    status: Running,
    waiting: 0,
    task: None,
  }
}

///|
/// Check if the task is failed and return the error
pub fn Task::is_fail(self : Self) -> Error? {
  match self.status {
    Fail(err) => Some(err)
    _ => None
  }
}

///|
/// Check if all waitables are done
pub fn Task::no_wait(self : Self) -> Bool {
  self.waiting == 0
}

///|
/// Check if the task is done or failed
pub fn Task::is_done(self : Self) -> Bool {
  match self.status {
    Done => true
    Fail(_) => true
    Running => false
  }
}

///|
pub fn Task::handle(self : Self) -> Int {
  self.id
}

///|
pub fn Task::blocking_wait(self : Self) -> (Int, Int, Int) {
  let result : FixedArray[Int] = FixedArray::make(2, 0)
  let result_ptr = int_array2ptr(result)
  let event0 = waitable_set_wait(self.id, result_ptr)
  _async_debug("waitable_set_wait(\{event0}, \{result[0]}, \{result[1]})")
  (event0, result[0], result[1])
}

///|
pub fn Task::blocking_poll(self : Self) -> (Int, Int, Int) {
  let result : FixedArray[Int] = FixedArray::make(2, 0)
  let result_ptr = int_array2ptr(result)
  let event0 = waitable_set_poll(self.id, result_ptr)
  _async_debug("waitable-set-poll(\{event0}, \{result[0]}, \{result[1]})")
  (event0, result[0], result[1])
}

///|
/// Add a waitable to the waitable set and increase the waiting count
pub fn[T : Waitable] Task::add_waitable(
  self : Self,
  waitable : T,
  coro : Coroutine,
) -> Unit {
  waitable_join(waitable.handle(), self.id)
  self.children[waitable.handle()] = (waitable, coro)
  self.resources.push_back(waitable.handle())
  _async_debug("waitable-set-join(\{waitable.handle()}, \{self.id})")
  self.waiting += 1
}

///|
/// When a waitable is done will be removed from the waitable set
/// then waitable will be try to drop
pub fn[T : Waitable] Task::remove_waitable(self : Self, state : T) -> Unit {
  _async_debug("waitable-set-join(\{state.handle()}, 0)")
  waitable_join(state.handle(), 0)
  self.waiting -= 1
}

///|
pub fn[T : Waitable] Task::drop_waitable(self : Self, state : T) -> Unit {
  let _ = state.drop()
  if self.resources.search(state.handle()) is Some(idx) {
    let _ = self.resources.remove(idx)

  }
  self.children.remove(state.handle())
}

///|
/// Cancel a waitable, remove it from the waitable set and force drop it
pub fn[T : Waitable] Task::cancel_waitable(self : Self, state : T) -> Unit {
  waitable_join(state.handle(), 0)
  _async_debug("waitable-set-join(\{state.handle()}, 0)")
  self.waiting -= 1
  state.cancel()
  let _ = state.drop()
  self.children.remove(state.handle())
}

///|
/// set current task context to 0 and let runner drop the waitable set
pub fn Task::drop(self : Self) -> Unit {
  context_set(0)
  defer waitable_set_drop(self.id)
  _async_debug("context-set(0)")
}

///|
/// Spawns a coroutine to execute an async function and without waits for its completion
/// while managing the waitable state.
pub fn Task::spawn(_self : Self, f : async () -> Unit) -> Unit {
  let coro = spawn(fn() { f() })
  // start the coroutine when first spawn
  coro.run()
  rschedule()
}

///|
/// This function spawns a coroutine to run the async function and waits for its completion
pub async fn Task::wait(_ : Self, f : async () -> Unit) -> Unit {
  let coro = spawn(fn() { f() })
  coro.run()
  rschedule()
  Coroutine::wait(coro)
}

///|
pub fn Task::add_defer(self : Self, f : () -> Unit raise) -> Unit {
  self.task_defer.push(f)
}

///|
pub fn callback(event : Int, waitable_id : Int, code : Int) -> Int {
  let event = Event::decode(event)
  _async_debug("callback(\{event}, \{waitable_id}, \{code})")
  let task = match current_waitable_set() {
    Some(task) => task
    None => current_task()
  }
  // Handle the event for the current waitable task
  match event {
    FutureRead | FutureWrite | StreamRead | StreamWrite | Subtask => {
      let (state, coro) = task.children[waitable_id]
      state.update(code~)
      // schedule next coroutine
      coro.wake()
      rschedule()
      if task.no_wait() && task.task is Some(parent) {
        // run the parent coroutine when all waitables are done
        // parent coroutine may execute return/cancel
        parent.wake()
        rschedule()
        return CallbackCode::Exit.encode()
      }
      return CallbackCode::Wait(task.id).encode()
    }
    TaskCancel => {
      if task.task is Some(parent) {
        parent.wake()
      }
      task.children
      .values()
      .each(child => {
        let (state, coro) = child
        task.cancel_waitable(state)
        coro.cancel()
      })
      rschedule()
      return CallbackCode::Exit.encode()
    }
    None => {
      rschedule()
      return CallbackCode::Exit.encode()
    }
  }
}

///|
pub fn Task::with_waitable_set(
  self : Self,
  f : async (Self) -> Unit,
  is_drop? : Bool = false,
) -> Coroutine noraise {
  let parent = spawn(async fn() -> Unit noraise {
    self.status = Running
    defer (if self.children.is_empty() {
      if self.status is Running {
        self.status = Done
      }
      task_map.remove(self.id)

      // this defer block recycles waitable task resources
      while self.task_defer.pop() is Some(defer_block) {
        defer_block() catch {
          err => if self.status is Done { self.status = Fail(err) }
        }
      }

      // runner will drop the waitable set
      // export async function needs to keep the waitable set
      if is_drop {
        self.drop()
      }
    })
    f(self) catch {
      err => if self.status is Running { self.status = Fail(err) }
    }
    if !self.no_wait() {
      _async_debug("task-wait-loop(\{self.id})")
      suspend() catch {
        err => if self.status is Running { self.status = Fail(err) }
      }
    }
    while self.resources.pop_front() is Some(handle) {
      let state = self.children.get(handle)
      if state is Some((state, _)) {
        let _ = state.drop()

      }
    }
  })
  self.task = Some(parent)
  // start the parent coroutine
  parent.run()
  rschedule()
  parent
}

///|
fn current_waitable_set() -> Task? {
  let ctx = context_get()
  _async_debug("context-get(\{ctx})")
  if ctx == 0 {
    None
  } else {
    match task_map.get(ctx) {
      Some(task) => Some(task)
      None => {
        let ctx = Task::from_raw(ctx)
        task_map[ctx.id] = ctx
        Some(ctx)
      }
    }
  }
}

///|
pub fn current_task() -> Task {
  let ctx = context_get()
  if ctx == 0 {
    let ctx = Task::new()
    task_map[ctx.id] = ctx
    ctx
  } else {
    match task_map.get(ctx) {
      Some(task) => task
      None => {
        let ctx = Task::from_raw(ctx)
        task_map[ctx.id] = ctx
        ctx
      }
    }
  }
}

///|
pub fn Task::run_forever(self : Self) -> Unit noraise {
  let _ = spawn(fn() { pause() })
  rschedule()
}

///|
pub async fn Task::poll(self : Self) -> Bool {
  if self.no_wait() {
    return false
  }
  let mut event = (0, 0, 0)
  for {
    let code = callback(event.0, event.1, event.2)
    match CallbackCode::decode(code) {
      Exit => return false
      Yield => event = self.blocking_poll()
      _ => event = self.blocking_wait()
    }
  }
  pause()
  true
}

///|
pub fn with_event_loop(f : async (Task) -> Unit) -> Unit raise {
  let self = current_task()
  let main = spawn(fn() { f(self) })
  self.run_forever()
  main.unwrap()
}

///|
pub struct Subtask {
  handle : Int
  mut code : Int?
  mut dropped : Bool
}

///|
pub fn Subtask::from_handle(handle : Int, code? : Int) -> Subtask {
  { handle, code: None, dropped: false }
}

///|
pub impl Waitable for Subtask with update(self, code~ : Int) -> Unit {
  self.code = Some(code)
}

///|
pub impl Eq for Subtask with equal(self, other) -> Bool {
  self.handle == other.handle
}

///|
pub impl Waitable for Subtask with handle(self) -> Int {
  self.handle
}

///|
pub impl Waitable for Subtask with cancel(self) -> Unit {
  if self.code is Some(code) && CallbackCode::decode(code) is Cancel(_) {
    return
  }
  self.code = Some(subtask_cancel(self.handle))
}

///|
pub impl Waitable for Subtask with drop(self) -> Bool {
  _async_debug("subtask-drop(\{self.handle})")
  if self.done() || self.dropped {
    return false
  }
  subtask_drop(self.handle)
  self.dropped = true
  true
}

///|
pub impl Waitable for Subtask with done(self) -> Bool {
  guard self.code is Some(code) else { return false }
  match SubtaskStatus::decode(code) {
    StartCancelled(_) => true
    Returned(_) => true
    Started(_) => false
    Starting(_) => false
    ReturnCancelled(_) => true
  }
}

///|
let std = 2

///|
pub fn print(msg : String) -> Unit {
  // let msg = msg + "\n"
  // let ret = try? @wasi.Fd(std).fd_write([@encoding.encode(msg, encoding=UTF8)])
  // match ret {
  //       Err(err) => {
  //             let _ = try? @wasi.Fd(std).fd_write([@encoding.encode(err.to_string(), encoding=UTF8)])

  //       }
  //       Ok(_) => return
  // }
}
