// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
///|
/// Lookup error codes.
pub(all) enum ErrorCode {
  UNKNOWN
  ACCESS_DENIED
  INVALID_ARGUMENT
  NAME_UNRESOLVABLE
  TEMPORARY_RESOLVER_FAILURE
  PERMANENT_RESOLVER_FAILURE
}

///|
pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
  match self {
    UNKNOWN => 0
    ACCESS_DENIED => 1
    INVALID_ARGUMENT => 2
    NAME_UNRESOLVABLE => 3
    TEMPORARY_RESOLVER_FAILURE => 4
    PERMANENT_RESOLVER_FAILURE => 5
  }
}

///|
pub fn ErrorCode::from(self : Int) -> ErrorCode {
  match self {
    0 => UNKNOWN
    1 => ACCESS_DENIED
    2 => INVALID_ARGUMENT
    3 => NAME_UNRESOLVABLE
    4 => TEMPORARY_RESOLVER_FAILURE
    5 => PERMANENT_RESOLVER_FAILURE
    _ => panic()
  }
}

///|
/// Resolve an internet host name to a list of IP addresses.
///
/// Unicode domain names are automatically converted to ASCII using IDNA encoding.
/// If the input is an IP address string, the address is parsed and returned
/// as-is without making any external requests.
///
/// See the wasi-socket proposal README.md for a comparison with getaddrinfo.
///
/// The results are returned in connection order preference.
///
/// This function never succeeds with 0 results. It either fails or succeeds
/// with at least one address. Additionally, this function never returns
/// IPv4-mapped IPv6 addresses.
///
/// The returned future will resolve to an error code in case of failure.
/// It will resolve to success once the returned stream is exhausted.
///
/// # References:
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html>
/// - <https://man7.org/linux/man-pages/man3/getaddrinfo.3.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getaddrinfo>
/// - <https://man.freebsd.org/cgi/man.cgi?query=getaddrinfo&sektion=3>
pub async fn resolve_addresses(
  name : String,
) -> Result[Array[@types.IpAddress], ErrorCode] {
  let _result_ptr = @ffi.malloc(12 * 1)
  let _subtask_code = wasmImportAsyncResolveAddresses(
    @ffi.str2ptr(name),
    name.length(),
    _result_ptr,
  )
  let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
  let _subtask = @ffi.Subtask::from_handle(
    _subtask_status.handle(),
    code=_subtask_code,
  )
  let task = @ffi.current_task()
  task.add_waitable(_subtask, @ffi.current_coroutine())
  defer task.remove_waitable(_subtask)
  for {
    if _subtask.done() || _subtask_status is Returned(_) {
      break
    } else {
      @ffi.suspend()
    }
  }
  let lifted8 = match @ffi.load8_u(_result_ptr + 0) {
    0 => {
      let array : Array[@types.IpAddress] = []
      for index = 0; index < @ffi.load32(_result_ptr + 8); index = index + 1 {
        let base1 = @ffi.load32(_result_ptr + 4) + index * 18
        let lifted = match @ffi.load8_u(base1 + 0) {
          0 =>
            @types.IpAddress::Ipv4(
              (
                @ffi.load8_u(base1 + 2).to_byte(),
                @ffi.load8_u(base1 + 3).to_byte(),
                @ffi.load8_u(base1 + 4).to_byte(),
                @ffi.load8_u(base1 + 5).to_byte(),
              ),
            )
          1 =>
            @types.IpAddress::Ipv6(
              (
                @ffi.load16_u(base1 + 2).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 4).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 6).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 8).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 10).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 12).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 14).land(0xFFFF).reinterpret_as_uint(),
                @ffi.load16_u(base1 + 16).land(0xFFFF).reinterpret_as_uint(),
              ),
            )
          _ => panic()
        }
        array.push(lifted)
      }
      @ffi.free(@ffi.load32(_result_ptr + 4))
      Result::Ok(array)
    }
    1 => Result::Err(ErrorCode::from(@ffi.load8_u(_result_ptr + 4)))
    _ => panic()
  }
  lifted8
}
