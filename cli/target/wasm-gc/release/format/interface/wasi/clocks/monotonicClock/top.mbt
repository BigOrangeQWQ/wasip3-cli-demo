// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
///|
/// Read the current value of the clock.
///
/// The clock is monotonic, therefore calling this function repeatedly will
/// produce a sequence of non-decreasing values.
///
/// For completeness, this function traps if it's not possible to represent
/// the value of the clock in an `instant`. Consequently, implementations
/// should ensure that the starting time is low enough to avoid the
/// possibility of overflow in practice.
pub fn now() -> UInt64 {
  let result : Int64 = wasmImportNow()
  return result.reinterpret_as_uint64()
}

///|
/// Query the resolution of the clock. Returns the duration of time
/// corresponding to a clock tick.
pub fn get_resolution() -> UInt64 {
  let result : Int64 = wasmImportGetResolution()
  return result.reinterpret_as_uint64()
}

///|
/// Wait until the specified instant has occurred.
pub async fn wait_until(when : UInt64) -> Unit {
  let _subtask_code = wasmImportAsyncWaitUntil(when.reinterpret_as_int64())
  let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
  let _subtask = @ffi.Subtask::from_handle(
    _subtask_status.handle(),
    code=_subtask_code,
  )
  let task = @ffi.current_task()
  task.add_waitable(_subtask, @ffi.current_coroutine())
  defer task.remove_waitable(_subtask)
  for {
    if _subtask.done() || _subtask_status is Returned(_) {
      break
    } else {
      @ffi.suspend()
    }
  }
}

///|
/// Wait for the specified duration to elapse.
pub async fn wait_for(how_long : UInt64) -> Unit {
  let _subtask_code = wasmImportAsyncWaitFor(how_long.reinterpret_as_int64())
  let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
  let _subtask = @ffi.Subtask::from_handle(
    _subtask_status.handle(),
    code=_subtask_code,
  )
  let task = @ffi.current_task()
  task.add_waitable(_subtask, @ffi.current_coroutine())
  defer task.remove_waitable(_subtask)
  for {
    if _subtask.done() || _subtask_status is Returned(_) {
      break
    } else {
      @ffi.suspend()
    }
  }
}
