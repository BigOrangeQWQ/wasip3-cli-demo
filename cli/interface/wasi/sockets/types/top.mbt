// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
/// Error codes.
///
/// In theory, every API can return any error code.
/// In practice, API's typically only return the errors documented per API
/// combined with a couple of errors that are always possible:
/// - `unknown`
/// - `access-denied`
/// - `not-supported`
/// - `out-of-memory`
///
/// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
pub(all) enum ErrorCode {
      UNKNOWN; ACCESS_DENIED; NOT_SUPPORTED; INVALID_ARGUMENT; OUT_OF_MEMORY; TIMEOUT; INVALID_STATE; ADDRESS_NOT_BINDABLE; ADDRESS_IN_USE; REMOTE_UNREACHABLE; CONNECTION_REFUSED; CONNECTION_RESET; CONNECTION_ABORTED; DATAGRAM_TOO_LARGE
} derive()

pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
      match self {
            UNKNOWN => 0
            ACCESS_DENIED => 1
            NOT_SUPPORTED => 2
            INVALID_ARGUMENT => 3
            OUT_OF_MEMORY => 4
            TIMEOUT => 5
            INVALID_STATE => 6
            ADDRESS_NOT_BINDABLE => 7
            ADDRESS_IN_USE => 8
            REMOTE_UNREACHABLE => 9
            CONNECTION_REFUSED => 10
            CONNECTION_RESET => 11
            CONNECTION_ABORTED => 12
            DATAGRAM_TOO_LARGE => 13
      }
}

pub fn ErrorCode::from(self : Int) -> ErrorCode {
      match self {
            0 => UNKNOWN
            1 => ACCESS_DENIED
            2 => NOT_SUPPORTED
            3 => INVALID_ARGUMENT
            4 => OUT_OF_MEMORY
            5 => TIMEOUT
            6 => INVALID_STATE
            7 => ADDRESS_NOT_BINDABLE
            8 => ADDRESS_IN_USE
            9 => REMOTE_UNREACHABLE
            10 => CONNECTION_REFUSED
            11 => CONNECTION_RESET
            12 => CONNECTION_ABORTED
            13 => DATAGRAM_TOO_LARGE
            _ => panic()
      }
}

pub(all) enum IpAddressFamily {
      IPV4; IPV6
} derive()

pub fn IpAddressFamily::ordinal(self : IpAddressFamily) -> Int {
      match self {
            IPV4 => 0
            IPV6 => 1
      }
}

pub fn IpAddressFamily::from(self : Int) -> IpAddressFamily {
      match self {
            0 => IPV4
            1 => IPV6
            _ => panic()
      }
}

pub(all) enum IpAddress {
      Ipv4((Byte, Byte, Byte, Byte))
      Ipv6((UInt, UInt, UInt, UInt, UInt, UInt, UInt, UInt))
} derive()

pub(all) struct Ipv4SocketAddress {
      port : UInt; address : (Byte, Byte, Byte, Byte)
} derive()

pub(all) struct Ipv6SocketAddress {
      port : UInt; flow_info : UInt; address : (UInt, UInt, UInt, UInt, UInt, UInt, UInt, UInt); scope_id : UInt
} derive()

pub(all) enum IpSocketAddress {
      Ipv4(Ipv4SocketAddress)
      Ipv6(Ipv6SocketAddress)
} derive()
/// A TCP socket resource.
///
/// The socket can be in one of the following states:
/// - `unbound`
/// - `bound` (See note below)
/// - `listening`
/// - `connecting`
/// - `connected`
/// - `closed`
/// See <https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics-0.3.0-draft.md>
/// for more information.
///
/// Note: Except where explicitly mentioned, whenever this documentation uses
/// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
/// (i.e. `bound`, `listening`, `connecting` or `connected`)
///
/// In addition to the general error codes documented on the
/// `types::error-code` type, TCP socket methods may always return
/// `error(invalid-state)` when in the `closed` state.
pub(all) struct TcpSocket(Int) derive()

/// Drops a resource handle.
pub fn TcpSocket::drop(self : TcpSocket) -> Unit {
      let TcpSocket(resource) = self
      wasmImportResourceDropTcpSocket(resource)
}
/// A UDP socket handle.
pub(all) struct UdpSocket(Int) derive()

/// Drops a resource handle.
pub fn UdpSocket::drop(self : UdpSocket) -> Unit {
      let UdpSocket(resource) = self
      wasmImportResourceDropUdpSocket(resource)
}
/// Create a new TCP socket.
///
/// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
/// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
///
/// Unlike POSIX, WASI sockets have no notion of a socket-level
/// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
/// async support.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
/// - <https://man7.org/linux/man-pages/man2/socket.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
/// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
pub fn TcpSocket::create(address_family : IpAddressFamily) -> Result[TcpSocket, ErrorCode] {

      let return_area = @ffi.malloc(8)
      wasmImportStaticTcpSocketCreate(address_family.ordinal(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(TcpSocket::TcpSocket(@ffi.load32((return_area) + 4)))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Bind the socket to the provided IP address and port.
///
/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
/// network interface(s) to bind to.
/// If the TCP/UDP port is zero, the socket will be bound to a random free port.
///
/// Bind can be attempted multiple times on the same socket, even with
/// different arguments on each iteration. But never concurrently and
/// only as long as the previous bind failed. Once a bind succeeds, the
/// binding can't be changed anymore.
///
/// # Typical errors
/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
/// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
/// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
/// - `invalid-state`:             The socket is already bound. (EINVAL)
/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
/// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
///
/// # Implementors note
/// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
/// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
/// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
/// and SO_REUSEADDR performs something different entirely.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
pub fn TcpSocket::bind(self : TcpSocket, local_address : IpSocketAddress) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self

      let (lowered,lowered3,lowered4,lowered5,lowered6,lowered7,lowered8,lowered9,lowered10,lowered11,lowered12,lowered13) = match local_address {
            Ipv4(payload) => {

                  ((0), ((payload).port).reinterpret_as_int(), (((payload).address).0).to_int(), (((payload).address).1).to_int(), (((payload).address).2).to_int(), (((payload).address).3).to_int(), 0, 0, 0, 0, 0, 0)
            }
            Ipv6(payload2) => {

                  ((1), ((payload2).port).reinterpret_as_int(), ((payload2).flow_info).reinterpret_as_int(), (((payload2).address).0).reinterpret_as_int(), (((payload2).address).1).reinterpret_as_int(), (((payload2).address).2).reinterpret_as_int(), (((payload2).address).3).reinterpret_as_int(), (((payload2).address).4).reinterpret_as_int(), (((payload2).address).5).reinterpret_as_int(), (((payload2).address).6).reinterpret_as_int(), (((payload2).address).7).reinterpret_as_int(), ((payload2).scope_id).reinterpret_as_int())
            }
      }
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketBind(handle, lowered, lowered3, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Connect to a remote endpoint.
///
/// On success, the socket is transitioned into the `connected` state and this function returns a connection resource.
///
/// After a failed connection attempt, the socket will be in the `closed`
/// state and the only valid action left is to `drop` the socket. A single
/// socket can not be used to connect more than once.
///
/// # Typical errors
/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
/// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
/// - `invalid-state`:             The socket is already in the `connecting` state. (EALREADY)
/// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
/// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
/// - `timeout`:                   Connection timed out. (ETIMEDOUT)
/// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
/// - `connection-reset`:          The connection was reset. (ECONNRESET)
/// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
/// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
/// - <https://man.freebsd.org/cgi/man.cgi?connect>
pub async fn TcpSocket::connect(self : TcpSocket, remote_address : IpSocketAddress) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(36)

      let TcpSocket(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)

      match remote_address {
            Ipv4(payload) => {
                  @ffi.store8((_lower_ptr + 4) + 0, (0))
                  @ffi.store16((_lower_ptr + 4) + 4, ((payload).port).reinterpret_as_int())
                  @ffi.store8((_lower_ptr + 4) + 6, (((payload).address).0).to_int())
                  @ffi.store8((_lower_ptr + 4) + 7, (((payload).address).1).to_int())
                  @ffi.store8((_lower_ptr + 4) + 8, (((payload).address).2).to_int())
                  @ffi.store8((_lower_ptr + 4) + 9, (((payload).address).3).to_int())

                  ()
            }
            Ipv6(payload2) => {
                  @ffi.store8((_lower_ptr + 4) + 0, (1))
                  @ffi.store16((_lower_ptr + 4) + 4, ((payload2).port).reinterpret_as_int())
                  @ffi.store32((_lower_ptr + 4) + 8, ((payload2).flow_info).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 12, (((payload2).address).0).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 14, (((payload2).address).1).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 16, (((payload2).address).2).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 18, (((payload2).address).3).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 20, (((payload2).address).4).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 22, (((payload2).address).5).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 24, (((payload2).address).6).reinterpret_as_int())
                  @ffi.store16((_lower_ptr + 4) + 26, (((payload2).address).7).reinterpret_as_int())
                  @ffi.store32((_lower_ptr + 4) + 28, ((payload2).scope_id).reinterpret_as_int())

                  ()
            }
      }

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodTcpSocketConnect(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}

fn wasmImportTcpSocketstreamNew() -> UInt64 = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-new-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamRead(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][stream-read-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamWrite(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][stream-write-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamCancelRead(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-cancel-read-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamCancelWrite(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-cancel-write-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamDropReadable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-drop-readable-0][method]tcp-socket.listen"
fn wasmImportTcpSocketstreamDropWritable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-drop-writable-0][method]tcp-socket.listen"
fn wasmTcpSocketstreamLift(ptr: Int) -> TcpSocket {

      TcpSocket::TcpSocket(@ffi.load32((ptr) + 0))
}
fn wasmTcpSocketstreamLower(value: TcpSocket, ptr: Int) -> Unit {

      let TcpSocket(handle) = value
      @ffi.store32((ptr) + 0, handle)

}
fn wasmTcpSocketstreamDeallocate(ptr: Int) -> Unit {

}
fn wasmTcpSocketstreamMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(4 * length);
      ptr
}
fn wasmTcpSocketstreamListLift(ptr: Int, length: Int) -> FixedArray[TcpSocket] {

      FixedArray::makei(
      length,
      (index) => {
            let ptr = (ptr) + (index * 4);
            wasmTcpSocketstreamLift(ptr)
      }
      )

}
fn wasmTcpSocketstreamListLower(value: FixedArray[TcpSocket]) -> Int {

      let address = @ffi.malloc((value).length() * 4);
      for index = 0; index < (value).length(); index = index + 1 {
            let ptr = (address) + (index * 4);
            let value = value[index];
            wasmTcpSocketstreamLower(value, ptr);
      }
      address

}
fn ffi_stream_reader_tcp_socket_stream_table() -> @ffi.StreamVTable[TcpSocket] {
      @ffi.StreamVTable::new(
      wasmImportTcpSocketstreamNew,
      wasmImportTcpSocketstreamRead,
      wasmImportTcpSocketstreamWrite,
      wasmImportTcpSocketstreamCancelRead,
      wasmImportTcpSocketstreamCancelWrite,
      wasmImportTcpSocketstreamDropReadable,
      wasmImportTcpSocketstreamDropWritable,
      wasmTcpSocketstreamMalloc,
      wasmTcpSocketstreamDeallocate,
      wasmTcpSocketstreamListLift,
      wasmTcpSocketstreamListLower,
      )
}

pub let static_ffi_stream_reader_tcp_socket_stream_table: @ffi.StreamVTable[TcpSocket]  = ffi_stream_reader_tcp_socket_stream_table();

/// Start listening and return a stream of new inbound connections.
///
/// Transitions the socket into the `listening` state. This can be called
/// at most once per socket.
///
/// If the socket is not already explicitly bound, this function will
/// implicitly bind the socket to a random free port.
///
/// Normally, the returned sockets are bound, in the `connected` state
/// and immediately ready for I/O. Though, depending on exact timing and
/// circumstances, a newly accepted connection may already be `closed`
/// by the time the server attempts to perform its first I/O on it. This
/// is true regardless of whether the WASI implementation uses
/// "synthesized" sockets or not (see Implementors Notes below).
///
/// The following properties are inherited from the listener socket:
/// - `address-family`
/// - `keep-alive-enabled`
/// - `keep-alive-idle-time`
/// - `keep-alive-interval`
/// - `keep-alive-count`
/// - `hop-limit`
/// - `receive-buffer-size`
/// - `send-buffer-size`
///
/// # Typical errors
/// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
/// - `invalid-state`:             The socket is already in the `listening` state.
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
///
/// # Implementors note
/// This method returns a single perpetual stream that should only close
/// on fatal errors (if any). Yet, the POSIX' `accept` function may also
/// return transient errors (e.g. ECONNABORTED). The exact details differ
/// per operation system. For example, the Linux manual mentions:
///
/// > Linux accept() passes already-pending network errors on the new
/// > socket as an error code from accept(). This behavior differs from
/// > other BSD socket implementations. For reliable operation the
/// > application should detect the network errors defined for the
/// > protocol after accept() and treat them like EAGAIN by retrying.
/// > In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT,
/// > EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH.
/// Source: https://man7.org/linux/man-pages/man2/accept.2.html
///
/// WASI implementations have two options to handle this:
/// - Optionally log it and then skip over non-fatal errors returned by
///   `accept`. Guest code never gets to see these failures. Or:
/// - Synthesize a `tcp-socket` resource that exposes the error when
///   attempting to send or receive on it. Guest code then sees these
///   failures as regular I/O errors.
///
/// In either case, the stream returned by this `listen` method remains
/// operational.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
/// - <https://man7.org/linux/man-pages/man2/listen.2.html>
/// - <https://man7.org/linux/man-pages/man2/accept.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
/// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
/// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
pub fn TcpSocket::listen(self : TcpSocket) -> Result[@ffi.StreamReader[TcpSocket], ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodTcpSocketListen(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {
                  let result = @ffi.StreamReader::new(@ffi.load32((return_area) + 4), static_ffi_stream_reader_tcp_socket_stream_table);

                  Result::Ok(result)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

fn wasmImportBytestreamNew() -> UInt64 = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-new-0][async method]tcp-socket.send"
fn wasmImportBytestreamRead(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][stream-read-0][async method]tcp-socket.send"
fn wasmImportBytestreamWrite(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][stream-write-0][async method]tcp-socket.send"
fn wasmImportBytestreamCancelRead(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-cancel-read-0][async method]tcp-socket.send"
fn wasmImportBytestreamCancelWrite(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-cancel-write-0][async method]tcp-socket.send"
fn wasmImportBytestreamDropReadable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-drop-readable-0][async method]tcp-socket.send"
fn wasmImportBytestreamDropWritable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[stream-drop-writable-0][async method]tcp-socket.send"
fn wasmBytestreamLift(ptr: Int) -> Byte {

      (@ffi.load8_u((ptr) + 0)).to_byte()
}
fn wasmBytestreamLower(value: Byte, ptr: Int) -> Unit {
      @ffi.store8((ptr) + 0, (value).to_int())

}
fn wasmBytestreamDeallocate(ptr: Int) -> Unit {

}
fn wasmBytestreamMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(1 * length);
      ptr
}
fn wasmBytestreamListLift(ptr: Int, length: Int) -> FixedArray[Byte] {
      @ffi.ptr2bytes(ptr, length)
}
fn wasmBytestreamListLower(value: FixedArray[Byte]) -> Int {
      @ffi.bytes2ptr(value)
}
fn ffi_stream_reader_byte_stream_table() -> @ffi.StreamVTable[Byte] {
      @ffi.StreamVTable::new(
      wasmImportBytestreamNew,
      wasmImportBytestreamRead,
      wasmImportBytestreamWrite,
      wasmImportBytestreamCancelRead,
      wasmImportBytestreamCancelWrite,
      wasmImportBytestreamDropReadable,
      wasmImportBytestreamDropWritable,
      wasmBytestreamMalloc,
      wasmBytestreamDeallocate,
      wasmBytestreamListLift,
      wasmBytestreamListLower,
      )
}

pub let static_ffi_stream_reader_byte_stream_table: @ffi.StreamVTable[Byte]  = ffi_stream_reader_byte_stream_table();

/// Transmit data to peer.
///
/// The caller should close the stream when it has no more data to send
/// to the peer. Under normal circumstances this will cause a FIN packet
/// to be sent out. Closing the stream is equivalent to calling
/// `shutdown(SHUT_WR)` in POSIX.
///
/// This function may be called at most once and returns once the full
/// contents of the stream are transmitted or an error is encountered.
///
/// # Typical errors
/// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
/// - `connection-reset`:          The connection was reset. (ECONNRESET)
/// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
///
///  # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html>
/// - <https://man7.org/linux/man-pages/man2/send.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
/// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
pub async fn TcpSocket::send(self : TcpSocket, data : @ffi.StreamReader[Byte]) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self

      let TcpSocket(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodTcpSocketSend(handle, data.handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}

fn wasmImportResultUnitErrorCodefutureNew() -> UInt64 = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[future-new-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureRead(handle : Int, buffer_ptr : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][future-read-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureWrite(handle : Int, buffer_ptr : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[async-lower][future-write-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureCancelRead(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[future-cancel-read-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureCancelWrite(handle : Int) -> Int = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[future-cancel-write-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureDropReadable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[future-drop-readable-1][method]tcp-socket.receive"
fn wasmImportResultUnitErrorCodefutureDropWritable(handle : Int) = "wasi:sockets/types@0.3.0-rc-2025-09-16" "[future-drop-writable-1][method]tcp-socket.receive"
fn wasmResultUnitErrorCodefutureLift(ptr: Int) -> Result[Unit, ErrorCode] {

      let lifted = match (@ffi.load8_u((ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((ptr) + 1)))
            }
            _ => panic()
      }

      lifted
}
fn wasmResultUnitErrorCodefutureLower(value: Result[Unit, ErrorCode], ptr: Int) -> Unit {

      match value {
            Ok(_payload) => {
                  @ffi.store8((ptr) + 0, (0))

                  ()
            }
            Err(payload2) => {
                  @ffi.store8((ptr) + 0, (1))
                  @ffi.store8((ptr) + 1, payload2.ordinal())

                  ()
            }
      }

}
fn wasmResultUnitErrorCodefutureDeallocate(ptr: Int) -> Unit {

}
fn wasmResultUnitErrorCodefutureMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(2 * length);
      ptr
}
fn wasmResultUnitErrorCodefutureListLift(ptr: Int, length: Int) -> FixedArray[Result[Unit, ErrorCode]] {

      FixedArray::makei(
      length,
      (index) => {
            let ptr = (ptr) + (index * 2);
            wasmResultUnitErrorCodefutureLift(ptr)
      }
      )

}
fn wasmResultUnitErrorCodefutureListLower(value: FixedArray[Result[Unit, ErrorCode]]) -> Int {

      let address = @ffi.malloc((value).length() * 2);
      for index = 0; index < (value).length(); index = index + 1 {
            let ptr = (address) + (index * 2);
            let value = value[index];
            wasmResultUnitErrorCodefutureLower(value, ptr);
      }
      address

}
fn ffi_future_reader_result_unit_error_code_future_table() -> @ffi.FutureVTable[Result[Unit, ErrorCode]] {
      @ffi.FutureVTable::new(
      wasmImportResultUnitErrorCodefutureNew,
      wasmImportResultUnitErrorCodefutureRead,
      wasmImportResultUnitErrorCodefutureWrite,
      wasmImportResultUnitErrorCodefutureCancelRead,
      wasmImportResultUnitErrorCodefutureCancelWrite,
      wasmImportResultUnitErrorCodefutureDropReadable,
      wasmImportResultUnitErrorCodefutureDropWritable,
      wasmResultUnitErrorCodefutureMalloc,
      wasmResultUnitErrorCodefutureDeallocate,
      wasmResultUnitErrorCodefutureLift,
      wasmResultUnitErrorCodefutureLower,
      )
}

pub let static_ffi_future_reader_result_unit_error_code_future_table: @ffi.FutureVTable[Result[Unit, ErrorCode]]  = ffi_future_reader_result_unit_error_code_future_table();

/// Read data from peer.
///
/// This function returns a `stream` which provides the data received from the
/// socket, and a `future` providing additional error information in case the
/// socket is closed abnormally.
///
/// If the socket is closed normally, `stream.read` on the `stream` will return
/// `read-status::closed` with no `error-context` and the future resolves to
/// the value `ok`. If the socket is closed abnormally, `stream.read` on the
/// `stream` returns `read-status::closed` with an `error-context` and the future
/// resolves to `err` with an `error-code`.
///
/// `receive` is meant to be called only once per socket. If it is called more
/// than once, the subsequent calls return a new `stream` that fails as if it
/// were closed abnormally.
///
/// If the caller is not expecting to receive any data from the peer,
/// they may drop the stream. Any data still in the receive queue
/// will be discarded. This is equivalent to calling `shutdown(SHUT_RD)`
/// in POSIX.
///
/// # Typical errors
/// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
/// - `connection-reset`:          The connection was reset. (ECONNRESET)
/// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html>
/// - <https://man7.org/linux/man-pages/man2/recv.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
/// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
pub fn TcpSocket::receive(self : TcpSocket) -> (@ffi.StreamReader[Byte], @ffi.FutureReader[Result[Unit, ErrorCode]]) {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodTcpSocketReceive(handle, return_area);
      let result = @ffi.StreamReader::new(@ffi.load32((return_area) + 0), static_ffi_stream_reader_byte_stream_table);
      let result0 = @ffi.FutureReader::new(@ffi.load32((return_area) + 4), static_ffi_future_reader_result_unit_error_code_future_table);
      @ffi.free(return_area)
      return (result, result0)

}
/// Get the bound local address.
///
/// POSIX mentions:
/// > If the socket has not been bound to a local name, the value
/// > stored in the object pointed to by `address` is unspecified.
///
/// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
///
/// # Typical errors
/// - `invalid-state`: The socket is not bound to any local address.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
pub fn TcpSocket::get_local_address(self : TcpSocket) -> Result[IpSocketAddress, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(36)
      wasmImportMethodTcpSocketGetLocalAddress(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              IpSocketAddress::Ipv4(Ipv4SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), address : ((@ffi.load8_u((return_area) + 10)).to_byte(), (@ffi.load8_u((return_area) + 11)).to_byte(), (@ffi.load8_u((return_area) + 12)).to_byte(), (@ffi.load8_u((return_area) + 13)).to_byte())})
                        }
                        1 => {

                              IpSocketAddress::Ipv6(Ipv6SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), flow_info : (@ffi.load32((return_area) + 12)).reinterpret_as_uint(), address : ((@ffi.load16_u((return_area) + 16).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 18).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 20).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 22).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 24).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 26).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 28).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 30).land(0xFFFF).reinterpret_as_uint())), scope_id : (@ffi.load32((return_area) + 32)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(lifted)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}
/// Get the remote address.
///
/// # Typical errors
/// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
pub fn TcpSocket::get_remote_address(self : TcpSocket) -> Result[IpSocketAddress, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(36)
      wasmImportMethodTcpSocketGetRemoteAddress(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              IpSocketAddress::Ipv4(Ipv4SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), address : ((@ffi.load8_u((return_area) + 10)).to_byte(), (@ffi.load8_u((return_area) + 11)).to_byte(), (@ffi.load8_u((return_area) + 12)).to_byte(), (@ffi.load8_u((return_area) + 13)).to_byte())})
                        }
                        1 => {

                              IpSocketAddress::Ipv6(Ipv6SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), flow_info : (@ffi.load32((return_area) + 12)).reinterpret_as_uint(), address : ((@ffi.load16_u((return_area) + 16).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 18).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 20).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 22).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 24).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 26).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 28).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 30).land(0xFFFF).reinterpret_as_uint())), scope_id : (@ffi.load32((return_area) + 32)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(lifted)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}
/// Whether the socket is in the `listening` state.
///
/// Equivalent to the SO_ACCEPTCONN socket option.
pub fn TcpSocket::get_is_listening(self : TcpSocket) -> Bool {

      let TcpSocket(handle) = self
      let result : Int =  wasmImportMethodTcpSocketGetIsListening(handle);
      return (result != 0)

}
/// Whether this is a IPv4 or IPv6 socket.
///
/// This is the value passed to the constructor.
///
/// Equivalent to the SO_DOMAIN socket option.
pub fn TcpSocket::get_address_family(self : TcpSocket) -> IpAddressFamily {

      let TcpSocket(handle) = self
      let result : Int =  wasmImportMethodTcpSocketGetAddressFamily(handle);
      return IpAddressFamily::from(result)

}
/// Hints the desired listen queue size. Implementations are free to ignore this.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
///
/// # Typical errors
/// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
/// - `invalid-argument`:     (set) The provided value was 0.
/// - `invalid-state`:        (set) The socket is in the `connecting` or `connected` state.
pub fn TcpSocket::set_listen_backlog_size(self : TcpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetListenBacklogSize(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Enables or disables keepalive.
///
/// The keepalive behavior can be adjusted using:
/// - `keep-alive-idle-time`
/// - `keep-alive-interval`
/// - `keep-alive-count`
/// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
///
/// Equivalent to the SO_KEEPALIVE socket option.
pub fn TcpSocket::get_keep_alive_enabled(self : TcpSocket) -> Result[Bool, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketGetKeepAliveEnabled(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load8_u((return_area) + 1) != 0))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_keep_alive_enabled(self : TcpSocket, value : Bool) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetKeepAliveEnabled(handle, (if value { 1 } else { 0 }), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::get_keep_alive_idle_time(self : TcpSocket) -> Result[UInt64, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodTcpSocketGetKeepAliveIdleTime(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_keep_alive_idle_time(self : TcpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetKeepAliveIdleTime(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// The time between keepalive packets.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPINTVL socket option.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::get_keep_alive_interval(self : TcpSocket) -> Result[UInt64, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodTcpSocketGetKeepAliveInterval(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_keep_alive_interval(self : TcpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetKeepAliveInterval(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// The maximum amount of keepalive packets TCP should send before aborting the connection.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the TCP_KEEPCNT socket option.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::get_keep_alive_count(self : TcpSocket) -> Result[UInt, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodTcpSocketGetKeepAliveCount(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load32((return_area) + 4)).reinterpret_as_uint())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_keep_alive_count(self : TcpSocket, value : UInt) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetKeepAliveCount(handle, (value).reinterpret_as_int(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
pub fn TcpSocket::get_hop_limit(self : TcpSocket) -> Result[Byte, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketGetHopLimit(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load8_u((return_area) + 1)).to_byte())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_hop_limit(self : TcpSocket, value : Byte) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetHopLimit(handle, (value).to_int(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// The kernel buffer space reserved for sends/receives on this socket.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn TcpSocket::get_receive_buffer_size(self : TcpSocket) -> Result[UInt64, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodTcpSocketGetReceiveBufferSize(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_receive_buffer_size(self : TcpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetReceiveBufferSize(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::get_send_buffer_size(self : TcpSocket) -> Result[UInt64, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodTcpSocketGetSendBufferSize(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn TcpSocket::set_send_buffer_size(self : TcpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let TcpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodTcpSocketSetSendBufferSize(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Create a new UDP socket.
///
/// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
/// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
///
/// Unlike POSIX, WASI sockets have no notion of a socket-level
/// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
/// async support.
///
/// # References:
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
/// - <https://man7.org/linux/man-pages/man2/socket.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
/// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
pub fn UdpSocket::create(address_family : IpAddressFamily) -> Result[UdpSocket, ErrorCode] {

      let return_area = @ffi.malloc(8)
      wasmImportStaticUdpSocketCreate(address_family.ordinal(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(UdpSocket::UdpSocket(@ffi.load32((return_area) + 4)))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Bind the socket to the provided IP address and port.
///
/// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
/// network interface(s) to bind to.
/// If the port is zero, the socket will be bound to a random free port.
///
/// # Typical errors
/// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
/// - `invalid-state`:             The socket is already bound. (EINVAL)
/// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
/// - `address-in-use`:            Address is already in use. (EADDRINUSE)
/// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
/// - <https://man7.org/linux/man-pages/man2/bind.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
/// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
pub fn UdpSocket::bind(self : UdpSocket, local_address : IpSocketAddress) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self

      let (lowered,lowered3,lowered4,lowered5,lowered6,lowered7,lowered8,lowered9,lowered10,lowered11,lowered12,lowered13) = match local_address {
            Ipv4(payload) => {

                  ((0), ((payload).port).reinterpret_as_int(), (((payload).address).0).to_int(), (((payload).address).1).to_int(), (((payload).address).2).to_int(), (((payload).address).3).to_int(), 0, 0, 0, 0, 0, 0)
            }
            Ipv6(payload2) => {

                  ((1), ((payload2).port).reinterpret_as_int(), ((payload2).flow_info).reinterpret_as_int(), (((payload2).address).0).reinterpret_as_int(), (((payload2).address).1).reinterpret_as_int(), (((payload2).address).2).reinterpret_as_int(), (((payload2).address).3).reinterpret_as_int(), (((payload2).address).4).reinterpret_as_int(), (((payload2).address).5).reinterpret_as_int(), (((payload2).address).6).reinterpret_as_int(), (((payload2).address).7).reinterpret_as_int(), ((payload2).scope_id).reinterpret_as_int())
            }
      }
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketBind(handle, lowered, lowered3, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Associate this socket with a specific peer address.
///
/// On success, the `remote-address` of the socket is updated.
/// The `local-address` may be updated as well, based on the best network
/// path to `remote-address`. If the socket was not already explicitly
/// bound, this function will implicitly bind the socket to a random
/// free port.
///
/// When a UDP socket is "connected", the `send` and `receive` methods
/// are limited to communicating with that peer only:
/// - `send` can only be used to send to this destination.
/// - `receive` will only return datagrams sent from the provided `remote-address`.
///
/// The name "connect" was kept to align with the existing POSIX
/// terminology. Other than that, this function only changes the local
/// socket configuration and does not generate any network traffic.
/// The peer is not aware of this "connection".
///
/// This method may be called multiple times on the same socket to change
/// its association, but only the most recent one will be effective.
///
/// # Typical errors
/// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
///
/// # Implementors note
/// If the socket is already connected, some platforms (e.g. Linux)
/// require a disconnect before connecting to a different peer address.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
/// - <https://man.freebsd.org/cgi/man.cgi?connect>
pub fn UdpSocket::connect(self : UdpSocket, remote_address : IpSocketAddress) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self

      let (lowered,lowered3,lowered4,lowered5,lowered6,lowered7,lowered8,lowered9,lowered10,lowered11,lowered12,lowered13) = match remote_address {
            Ipv4(payload) => {

                  ((0), ((payload).port).reinterpret_as_int(), (((payload).address).0).to_int(), (((payload).address).1).to_int(), (((payload).address).2).to_int(), (((payload).address).3).to_int(), 0, 0, 0, 0, 0, 0)
            }
            Ipv6(payload2) => {

                  ((1), ((payload2).port).reinterpret_as_int(), ((payload2).flow_info).reinterpret_as_int(), (((payload2).address).0).reinterpret_as_int(), (((payload2).address).1).reinterpret_as_int(), (((payload2).address).2).reinterpret_as_int(), (((payload2).address).3).reinterpret_as_int(), (((payload2).address).4).reinterpret_as_int(), (((payload2).address).5).reinterpret_as_int(), (((payload2).address).6).reinterpret_as_int(), (((payload2).address).7).reinterpret_as_int(), ((payload2).scope_id).reinterpret_as_int())
            }
      }
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketConnect(handle, lowered, lowered3, lowered4, lowered5, lowered6, lowered7, lowered8, lowered9, lowered10, lowered11, lowered12, lowered13, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Dissociate this socket from its peer address.
///
/// After calling this method, `send` & `receive` are free to communicate
/// with any address again.
///
/// The POSIX equivalent of this is calling `connect` with an `AF_UNSPEC` address.
///
/// # Typical errors
/// - `invalid-state`:           The socket is not connected.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
/// - <https://man7.org/linux/man-pages/man2/connect.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
/// - <https://man.freebsd.org/cgi/man.cgi?connect>
pub fn UdpSocket::disconnect(self : UdpSocket) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketDisconnect(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// Send a message on the socket to a particular peer.
///
/// If the socket is connected, the peer address may be left empty. In
/// that case this is equivalent to `send` in POSIX. Otherwise it is
/// equivalent to `sendto`.
///
/// Additionally, if the socket is connected, a `remote-address` argument
/// _may_ be provided but then it must be identical to the address
/// passed to `connect`.
///
/// Implementations may trap if the `data` length exceeds 64 KiB.
///
/// # Typical errors
/// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
/// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
/// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `connect`. (EISCONN)
/// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
/// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
/// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
/// - <https://man7.org/linux/man-pages/man2/send.2.html>
/// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
/// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
pub async fn UdpSocket::send(self : UdpSocket, data : FixedArray[Byte], remote_address : IpSocketAddress?) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(48)

      let UdpSocket(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)
      @ffi.store32((_lower_ptr + 4) + 4, data.length())
      @ffi.store32((_lower_ptr + 4) + 0, @ffi.bytes2ptr(data))

      match ((remote_address)) {
            None => {
                  @ffi.store8((_lower_ptr + 12) + 0, (0))

                  ()
            }
            Some(payload2) => {
                  @ffi.store8((_lower_ptr + 12) + 0, (1))

                  match payload2 {
                        Ipv4(payload5) => {
                              @ffi.store8((_lower_ptr + 12) + 4, (0))
                              @ffi.store16((_lower_ptr + 12) + 8, ((payload5).port).reinterpret_as_int())
                              @ffi.store8((_lower_ptr + 12) + 10, (((payload5).address).0).to_int())
                              @ffi.store8((_lower_ptr + 12) + 11, (((payload5).address).1).to_int())
                              @ffi.store8((_lower_ptr + 12) + 12, (((payload5).address).2).to_int())
                              @ffi.store8((_lower_ptr + 12) + 13, (((payload5).address).3).to_int())

                              ()
                        }
                        Ipv6(payload8) => {
                              @ffi.store8((_lower_ptr + 12) + 4, (1))
                              @ffi.store16((_lower_ptr + 12) + 8, ((payload8).port).reinterpret_as_int())
                              @ffi.store32((_lower_ptr + 12) + 12, ((payload8).flow_info).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 16, (((payload8).address).0).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 18, (((payload8).address).1).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 20, (((payload8).address).2).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 22, (((payload8).address).3).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 24, (((payload8).address).4).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 26, (((payload8).address).5).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 28, (((payload8).address).6).reinterpret_as_int())
                              @ffi.store16((_lower_ptr + 12) + 30, (((payload8).address).7).reinterpret_as_int())
                              @ffi.store32((_lower_ptr + 12) + 32, ((payload8).scope_id).reinterpret_as_int())

                              ()
                        }
                  }

                  ()
            }
      }

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodUdpSocketSend(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Receive a message on the socket.
///
/// On success, the return value contains a tuple of the received data
/// and the address of the sender. Theoretical maximum length of the
/// data is 64 KiB. Though in practice, it will typically be less than
/// 1500 bytes.
///
/// If the socket is connected, the sender address is guaranteed to
/// match the remote address passed to `connect`.
///
/// # Typical errors
/// - `invalid-state`:        The socket has not been bound yet.
/// - `remote-unreachable`:   The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
/// - `connection-refused`:   The connection was refused. (ECONNREFUSED)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
/// - <https://man7.org/linux/man-pages/man2/recv.2.html>
/// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg>
/// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
pub async fn UdpSocket::receive(self : UdpSocket) -> Result[(FixedArray[Byte], IpSocketAddress), ErrorCode] {

      let UdpSocket(handle) = self

      let _result_ptr = @ffi.malloc(44 * 1);

      let _subtask_code = wasmImportAsyncMethodUdpSocketReceive(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted6 = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  let result = @ffi.ptr2bytes(@ffi.load32((_result_ptr) + 4), @ffi.load32((_result_ptr) + 8))

                  let lifted = match (@ffi.load8_u((_result_ptr) + 12)) {
                        0 => {

                              IpSocketAddress::Ipv4(Ipv4SocketAddress::{port : (@ffi.load16_u((_result_ptr) + 16).land(0xFFFF).reinterpret_as_uint()), address : ((@ffi.load8_u((_result_ptr) + 18)).to_byte(), (@ffi.load8_u((_result_ptr) + 19)).to_byte(), (@ffi.load8_u((_result_ptr) + 20)).to_byte(), (@ffi.load8_u((_result_ptr) + 21)).to_byte())})
                        }
                        1 => {

                              IpSocketAddress::Ipv6(Ipv6SocketAddress::{port : (@ffi.load16_u((_result_ptr) + 16).land(0xFFFF).reinterpret_as_uint()), flow_info : (@ffi.load32((_result_ptr) + 20)).reinterpret_as_uint(), address : ((@ffi.load16_u((_result_ptr) + 24).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 26).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 28).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 30).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 32).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 34).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 36).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((_result_ptr) + 38).land(0xFFFF).reinterpret_as_uint())), scope_id : (@ffi.load32((_result_ptr) + 40)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok((result, lifted))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 4)))
            }
            _ => panic()
      }

      lifted6

}
/// Get the current bound address.
///
/// POSIX mentions:
/// > If the socket has not been bound to a local name, the value
/// > stored in the object pointed to by `address` is unspecified.
///
/// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
///
/// # Typical errors
/// - `invalid-state`: The socket is not bound to any local address.
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
/// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
/// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
pub fn UdpSocket::get_local_address(self : UdpSocket) -> Result[IpSocketAddress, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(36)
      wasmImportMethodUdpSocketGetLocalAddress(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              IpSocketAddress::Ipv4(Ipv4SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), address : ((@ffi.load8_u((return_area) + 10)).to_byte(), (@ffi.load8_u((return_area) + 11)).to_byte(), (@ffi.load8_u((return_area) + 12)).to_byte(), (@ffi.load8_u((return_area) + 13)).to_byte())})
                        }
                        1 => {

                              IpSocketAddress::Ipv6(Ipv6SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), flow_info : (@ffi.load32((return_area) + 12)).reinterpret_as_uint(), address : ((@ffi.load16_u((return_area) + 16).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 18).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 20).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 22).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 24).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 26).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 28).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 30).land(0xFFFF).reinterpret_as_uint())), scope_id : (@ffi.load32((return_area) + 32)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(lifted)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}
/// Get the address the socket is currently "connected" to.
///
/// # Typical errors
/// - `invalid-state`: The socket is not "connected" to a specific remote address. (ENOTCONN)
///
/// # References
/// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
/// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
/// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
/// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
pub fn UdpSocket::get_remote_address(self : UdpSocket) -> Result[IpSocketAddress, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(36)
      wasmImportMethodUdpSocketGetRemoteAddress(handle, return_area);

      let lifted6 = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  let lifted = match (@ffi.load8_u((return_area) + 4)) {
                        0 => {

                              IpSocketAddress::Ipv4(Ipv4SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), address : ((@ffi.load8_u((return_area) + 10)).to_byte(), (@ffi.load8_u((return_area) + 11)).to_byte(), (@ffi.load8_u((return_area) + 12)).to_byte(), (@ffi.load8_u((return_area) + 13)).to_byte())})
                        }
                        1 => {

                              IpSocketAddress::Ipv6(Ipv6SocketAddress::{port : (@ffi.load16_u((return_area) + 8).land(0xFFFF).reinterpret_as_uint()), flow_info : (@ffi.load32((return_area) + 12)).reinterpret_as_uint(), address : ((@ffi.load16_u((return_area) + 16).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 18).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 20).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 22).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 24).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 26).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 28).land(0xFFFF).reinterpret_as_uint()), (@ffi.load16_u((return_area) + 30).land(0xFFFF).reinterpret_as_uint())), scope_id : (@ffi.load32((return_area) + 32)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(lifted)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 4)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted6

}
/// Whether this is a IPv4 or IPv6 socket.
///
/// This is the value passed to the constructor.
///
/// Equivalent to the SO_DOMAIN socket option.
pub fn UdpSocket::get_address_family(self : UdpSocket) -> IpAddressFamily {

      let UdpSocket(handle) = self
      let result : Int =  wasmImportMethodUdpSocketGetAddressFamily(handle);
      return IpAddressFamily::from(result)

}
/// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
pub fn UdpSocket::get_unicast_hop_limit(self : UdpSocket) -> Result[Byte, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketGetUnicastHopLimit(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load8_u((return_area) + 1)).to_byte())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn UdpSocket::set_unicast_hop_limit(self : UdpSocket, value : Byte) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketSetUnicastHopLimit(handle, (value).to_int(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}
/// The kernel buffer space reserved for sends/receives on this socket.
///
/// If the provided value is 0, an `invalid-argument` error is returned.
/// Any other value will never cause an error, but it might be silently clamped and/or rounded.
/// I.e. after setting a value, reading the same setting back may return a different value.
///
/// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
///
/// # Typical errors
/// - `invalid-argument`:     (set) The provided value was 0.
pub fn UdpSocket::get_receive_buffer_size(self : UdpSocket) -> Result[UInt64, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodUdpSocketGetReceiveBufferSize(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn UdpSocket::set_receive_buffer_size(self : UdpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketSetReceiveBufferSize(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn UdpSocket::get_send_buffer_size(self : UdpSocket) -> Result[UInt64, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(16)
      wasmImportMethodUdpSocketGetSendBufferSize(handle, return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok((@ffi.load64((return_area) + 8)).reinterpret_as_uint64())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 8)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

pub fn UdpSocket::set_send_buffer_size(self : UdpSocket, value : UInt64) -> Result[Unit, ErrorCode] {

      let UdpSocket(handle) = self
      let return_area = @ffi.malloc(2)
      wasmImportMethodUdpSocketSetSendBufferSize(handle, (value).reinterpret_as_int64(), return_area);

      let lifted = match (@ffi.load8_u((return_area) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((return_area) + 1)))
            }
            _ => panic()
      }
      @ffi.free(return_area)
      return lifted

}

