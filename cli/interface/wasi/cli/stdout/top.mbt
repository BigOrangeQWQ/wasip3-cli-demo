// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
/// Write the given stream to stdout.
///
/// If the stream's writable end is dropped this function will either return
/// success once the entire contents of the stream have been written or an
/// error-code representing a failure.
///
/// Otherwise if there is an error the readable end of the stream will be
/// dropped and this function will return an error-code.
pub async fn write_via_stream(data : @ffi.StreamReader[Byte]) -> Result[Unit, @types.ErrorCode] {

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncWriteViaStream(data.handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(@types.ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}

