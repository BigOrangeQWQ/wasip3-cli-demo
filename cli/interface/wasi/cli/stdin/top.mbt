// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!

fn wasmImportBytestreamNew() -> UInt64 = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[stream-new-0]read-via-stream"
fn wasmImportBytestreamRead(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[async-lower][stream-read-0]read-via-stream"
fn wasmImportBytestreamWrite(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[async-lower][stream-write-0]read-via-stream"
fn wasmImportBytestreamCancelRead(handle : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[stream-cancel-read-0]read-via-stream"
fn wasmImportBytestreamCancelWrite(handle : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[stream-cancel-write-0]read-via-stream"
fn wasmImportBytestreamDropReadable(handle : Int) = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[stream-drop-readable-0]read-via-stream"
fn wasmImportBytestreamDropWritable(handle : Int) = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[stream-drop-writable-0]read-via-stream"
fn wasmBytestreamLift(ptr: Int) -> Byte {

      (@ffi.load8_u((ptr) + 0)).to_byte()
}
fn wasmBytestreamLower(value: Byte, ptr: Int) -> Unit {
      @ffi.store8((ptr) + 0, (value).to_int())

}
fn wasmBytestreamDeallocate(ptr: Int) -> Unit {

}
fn wasmBytestreamMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(1 * length);
      ptr
}
fn wasmBytestreamListLift(ptr: Int, length: Int) -> FixedArray[Byte] {
      @ffi.ptr2bytes(ptr, length)
}
fn wasmBytestreamListLower(value: FixedArray[Byte]) -> Int {
      @ffi.bytes2ptr(value)
}
fn ffi_stream_reader_byte_stream_table() -> @ffi.StreamVTable[Byte] {
      @ffi.StreamVTable::new(
      wasmImportBytestreamNew,
      wasmImportBytestreamRead,
      wasmImportBytestreamWrite,
      wasmImportBytestreamCancelRead,
      wasmImportBytestreamCancelWrite,
      wasmImportBytestreamDropReadable,
      wasmImportBytestreamDropWritable,
      wasmBytestreamMalloc,
      wasmBytestreamDeallocate,
      wasmBytestreamListLift,
      wasmBytestreamListLower,
      )
}

pub let static_ffi_stream_reader_byte_stream_table: @ffi.StreamVTable[Byte]  = ffi_stream_reader_byte_stream_table();

fn wasmImportResultUnitTypesErrorCodefutureNew() -> UInt64 = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[future-new-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureRead(handle : Int, buffer_ptr : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[async-lower][future-read-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureWrite(handle : Int, buffer_ptr : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[async-lower][future-write-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureCancelRead(handle : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[future-cancel-read-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureCancelWrite(handle : Int) -> Int = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[future-cancel-write-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureDropReadable(handle : Int) = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[future-drop-readable-1]read-via-stream"
fn wasmImportResultUnitTypesErrorCodefutureDropWritable(handle : Int) = "wasi:cli/stdin@0.3.0-rc-2025-09-16" "[future-drop-writable-1]read-via-stream"
fn wasmResultUnitTypesErrorCodefutureLift(ptr: Int) -> Result[Unit, @types.ErrorCode] {

      let lifted = match (@ffi.load8_u((ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(@types.ErrorCode::from(@ffi.load8_u((ptr) + 1)))
            }
            _ => panic()
      }

      lifted
}
fn wasmResultUnitTypesErrorCodefutureLower(value: Result[Unit, @types.ErrorCode], ptr: Int) -> Unit {

      match value {
            Ok(_payload) => {
                  @ffi.store8((ptr) + 0, (0))

                  ()
            }
            Err(payload2) => {
                  @ffi.store8((ptr) + 0, (1))
                  @ffi.store8((ptr) + 1, payload2.ordinal())

                  ()
            }
      }

}
fn wasmResultUnitTypesErrorCodefutureDeallocate(ptr: Int) -> Unit {

}
fn wasmResultUnitTypesErrorCodefutureMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(2 * length);
      ptr
}
fn wasmResultUnitTypesErrorCodefutureListLift(ptr: Int, length: Int) -> FixedArray[Result[Unit, @types.ErrorCode]] {

      FixedArray::makei(
      length,
      (index) => {
            let ptr = (ptr) + (index * 2);
            wasmResultUnitTypesErrorCodefutureLift(ptr)
      }
      )

}
fn wasmResultUnitTypesErrorCodefutureListLower(value: FixedArray[Result[Unit, @types.ErrorCode]]) -> Int {

      let address = @ffi.malloc((value).length() * 2);
      for index = 0; index < (value).length(); index = index + 1 {
            let ptr = (address) + (index * 2);
            let value = value[index];
            wasmResultUnitTypesErrorCodefutureLower(value, ptr);
      }
      address

}
fn ffi_future_reader_result_unit_types_error_code_future_table() -> @ffi.FutureVTable[Result[Unit, @types.ErrorCode]] {
      @ffi.FutureVTable::new(
      wasmImportResultUnitTypesErrorCodefutureNew,
      wasmImportResultUnitTypesErrorCodefutureRead,
      wasmImportResultUnitTypesErrorCodefutureWrite,
      wasmImportResultUnitTypesErrorCodefutureCancelRead,
      wasmImportResultUnitTypesErrorCodefutureCancelWrite,
      wasmImportResultUnitTypesErrorCodefutureDropReadable,
      wasmImportResultUnitTypesErrorCodefutureDropWritable,
      wasmResultUnitTypesErrorCodefutureMalloc,
      wasmResultUnitTypesErrorCodefutureDeallocate,
      wasmResultUnitTypesErrorCodefutureLift,
      wasmResultUnitTypesErrorCodefutureLower,
      )
}

pub let static_ffi_future_reader_result_unit_types_error_code_future_table: @ffi.FutureVTable[Result[Unit, @types.ErrorCode]]  = ffi_future_reader_result_unit_types_error_code_future_table();

/// Return a stream for reading from stdin.
///
/// This function returns a stream which provides data read from stdin,
/// and a future to signal read results.
///
/// If the stream's readable end is dropped the future will resolve to success.
///
/// If the stream's writable end is dropped the future will either resolve to
/// success if stdin was closed by the writer or to an error-code if reading
/// failed for some other reason.
///
/// Multiple streams may be active at the same time. The behavior of concurrent
/// reads is implementation-specific.
pub fn read_via_stream() -> (@ffi.StreamReader[Byte], @ffi.FutureReader[Result[Unit, @types.ErrorCode]]) {

      let return_area = @ffi.malloc(8)
      wasmImportReadViaStream(return_area);
      let result = @ffi.StreamReader::new(@ffi.load32((return_area) + 0), static_ffi_stream_reader_byte_stream_table);
      let result0 = @ffi.FutureReader::new(@ffi.load32((return_area) + 4), static_ffi_future_reader_result_unit_types_error_code_future_table);
      @ffi.free(return_area)
      return (result, result0)

}

