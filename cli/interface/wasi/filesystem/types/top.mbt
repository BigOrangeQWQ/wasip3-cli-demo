// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!
/// The type of a filesystem object referenced by a descriptor.
///
/// Note: This was called `filetype` in earlier versions of WASI.
pub(all) enum DescriptorType {
      UNKNOWN; BLOCK_DEVICE; CHARACTER_DEVICE; DIRECTORY; FIFO; SYMBOLIC_LINK; REGULAR_FILE; SOCKET
} derive()

pub fn DescriptorType::ordinal(self : DescriptorType) -> Int {
      match self {
            UNKNOWN => 0
            BLOCK_DEVICE => 1
            CHARACTER_DEVICE => 2
            DIRECTORY => 3
            FIFO => 4
            SYMBOLIC_LINK => 5
            REGULAR_FILE => 6
            SOCKET => 7
      }
}

pub fn DescriptorType::from(self : Int) -> DescriptorType {
      match self {
            0 => UNKNOWN
            1 => BLOCK_DEVICE
            2 => CHARACTER_DEVICE
            3 => DIRECTORY
            4 => FIFO
            5 => SYMBOLIC_LINK
            6 => REGULAR_FILE
            7 => SOCKET
            _ => panic()
      }
}
/// Descriptor flags.
///
/// Note: This was called `fdflags` in earlier versions of WASI.
pub(all) struct DescriptorFlags(Byte) derive()
pub fn DescriptorFlags::default() -> DescriptorFlags {
      b'\x00'
}
pub(all) enum DescriptorFlagsFlag {
      READ; WRITE; FILE_INTEGRITY_SYNC; DATA_INTEGRITY_SYNC; REQUESTED_WRITE_SYNC; MUTATE_DIRECTORY
}
fn DescriptorFlagsFlag::value(self : DescriptorFlagsFlag) -> Byte {
      match self {
            READ => ((1U << 0).to_byte())
            WRITE => ((1U << 1).to_byte())
            FILE_INTEGRITY_SYNC => ((1U << 2).to_byte())
            DATA_INTEGRITY_SYNC => ((1U << 3).to_byte())
            REQUESTED_WRITE_SYNC => ((1U << 4).to_byte())
            MUTATE_DIRECTORY => ((1U << 5).to_byte())
      }
}
pub fn DescriptorFlags::set(self : Self, other: DescriptorFlagsFlag) -> DescriptorFlags {
      let DescriptorFlags(flag) = self
      flag.lor(other.value())
}
pub fn DescriptorFlags::unset(self : Self, other: DescriptorFlagsFlag) -> DescriptorFlags {
      let DescriptorFlags(flag) = self
      flag.land(other.value().lnot())
}
pub fn DescriptorFlags::is_set(self : Self, other: DescriptorFlagsFlag) -> Bool {
      let DescriptorFlags(flag) = self
      (flag.land(other.value()) == other.value())
}
/// Flags determining the method of how paths are resolved.
pub(all) struct PathFlags(Byte) derive()
pub fn PathFlags::default() -> PathFlags {
      b'\x00'
}
pub(all) enum PathFlagsFlag {
      SYMLINK_FOLLOW
}
fn PathFlagsFlag::value(self : PathFlagsFlag) -> Byte {
      match self {
            SYMLINK_FOLLOW => ((1U << 0).to_byte())
      }
}
pub fn PathFlags::set(self : Self, other: PathFlagsFlag) -> PathFlags {
      let PathFlags(flag) = self
      flag.lor(other.value())
}
pub fn PathFlags::unset(self : Self, other: PathFlagsFlag) -> PathFlags {
      let PathFlags(flag) = self
      flag.land(other.value().lnot())
}
pub fn PathFlags::is_set(self : Self, other: PathFlagsFlag) -> Bool {
      let PathFlags(flag) = self
      (flag.land(other.value()) == other.value())
}
/// Open flags used by `open-at`.
pub(all) struct OpenFlags(Byte) derive()
pub fn OpenFlags::default() -> OpenFlags {
      b'\x00'
}
pub(all) enum OpenFlagsFlag {
      CREATE; DIRECTORY; EXCLUSIVE; TRUNCATE
}
fn OpenFlagsFlag::value(self : OpenFlagsFlag) -> Byte {
      match self {
            CREATE => ((1U << 0).to_byte())
            DIRECTORY => ((1U << 1).to_byte())
            EXCLUSIVE => ((1U << 2).to_byte())
            TRUNCATE => ((1U << 3).to_byte())
      }
}
pub fn OpenFlags::set(self : Self, other: OpenFlagsFlag) -> OpenFlags {
      let OpenFlags(flag) = self
      flag.lor(other.value())
}
pub fn OpenFlags::unset(self : Self, other: OpenFlagsFlag) -> OpenFlags {
      let OpenFlags(flag) = self
      flag.land(other.value().lnot())
}
pub fn OpenFlags::is_set(self : Self, other: OpenFlagsFlag) -> Bool {
      let OpenFlags(flag) = self
      (flag.land(other.value()) == other.value())
}
/// File attributes.
///
/// Note: This was called `filestat` in earlier versions of WASI.
pub(all) struct DescriptorStat {
      type_ : DescriptorType; link_count : UInt64; size : UInt64; data_access_timestamp : @wallClock.Datetime?; data_modification_timestamp : @wallClock.Datetime?; status_change_timestamp : @wallClock.Datetime?
} derive()
/// When setting a timestamp, this gives the value to set it to.
pub(all) enum NewTimestamp {
      NoChange
      Now
      Timestamp(@wallClock.Datetime)
} derive()
/// A directory entry.
pub(all) struct DirectoryEntry {
      type_ : DescriptorType; name : String
} derive()
/// Error codes returned by functions, similar to `errno` in POSIX.
/// Not all of these error codes are returned by the functions provided by this
/// API; some are used in higher-level library layers, and others are provided
/// merely for alignment with POSIX.
pub(all) enum ErrorCode {
      ACCESS; ALREADY; BAD_DESCRIPTOR; BUSY; DEADLOCK; QUOTA; EXIST; FILE_TOO_LARGE; ILLEGAL_BYTE_SEQUENCE; IN_PROGRESS; INTERRUPTED; INVALID; IO; IS_DIRECTORY; LOOP; TOO_MANY_LINKS; MESSAGE_SIZE; NAME_TOO_LONG; NO_DEVICE; NO_ENTRY; NO_LOCK; INSUFFICIENT_MEMORY; INSUFFICIENT_SPACE; NOT_DIRECTORY; NOT_EMPTY; NOT_RECOVERABLE; UNSUPPORTED; NO_TTY; NO_SUCH_DEVICE; OVERFLOW; NOT_PERMITTED; PIPE; READ_ONLY; INVALID_SEEK; TEXT_FILE_BUSY; CROSS_DEVICE
} derive()

pub fn ErrorCode::ordinal(self : ErrorCode) -> Int {
      match self {
            ACCESS => 0
            ALREADY => 1
            BAD_DESCRIPTOR => 2
            BUSY => 3
            DEADLOCK => 4
            QUOTA => 5
            EXIST => 6
            FILE_TOO_LARGE => 7
            ILLEGAL_BYTE_SEQUENCE => 8
            IN_PROGRESS => 9
            INTERRUPTED => 10
            INVALID => 11
            IO => 12
            IS_DIRECTORY => 13
            LOOP => 14
            TOO_MANY_LINKS => 15
            MESSAGE_SIZE => 16
            NAME_TOO_LONG => 17
            NO_DEVICE => 18
            NO_ENTRY => 19
            NO_LOCK => 20
            INSUFFICIENT_MEMORY => 21
            INSUFFICIENT_SPACE => 22
            NOT_DIRECTORY => 23
            NOT_EMPTY => 24
            NOT_RECOVERABLE => 25
            UNSUPPORTED => 26
            NO_TTY => 27
            NO_SUCH_DEVICE => 28
            OVERFLOW => 29
            NOT_PERMITTED => 30
            PIPE => 31
            READ_ONLY => 32
            INVALID_SEEK => 33
            TEXT_FILE_BUSY => 34
            CROSS_DEVICE => 35
      }
}

pub fn ErrorCode::from(self : Int) -> ErrorCode {
      match self {
            0 => ACCESS
            1 => ALREADY
            2 => BAD_DESCRIPTOR
            3 => BUSY
            4 => DEADLOCK
            5 => QUOTA
            6 => EXIST
            7 => FILE_TOO_LARGE
            8 => ILLEGAL_BYTE_SEQUENCE
            9 => IN_PROGRESS
            10 => INTERRUPTED
            11 => INVALID
            12 => IO
            13 => IS_DIRECTORY
            14 => LOOP
            15 => TOO_MANY_LINKS
            16 => MESSAGE_SIZE
            17 => NAME_TOO_LONG
            18 => NO_DEVICE
            19 => NO_ENTRY
            20 => NO_LOCK
            21 => INSUFFICIENT_MEMORY
            22 => INSUFFICIENT_SPACE
            23 => NOT_DIRECTORY
            24 => NOT_EMPTY
            25 => NOT_RECOVERABLE
            26 => UNSUPPORTED
            27 => NO_TTY
            28 => NO_SUCH_DEVICE
            29 => OVERFLOW
            30 => NOT_PERMITTED
            31 => PIPE
            32 => READ_ONLY
            33 => INVALID_SEEK
            34 => TEXT_FILE_BUSY
            35 => CROSS_DEVICE
            _ => panic()
      }
}
/// File or memory access pattern advisory information.
pub(all) enum Advice {
      NORMAL; SEQUENTIAL; RANDOM; WILL_NEED; DONT_NEED; NO_REUSE
} derive()

pub fn Advice::ordinal(self : Advice) -> Int {
      match self {
            NORMAL => 0
            SEQUENTIAL => 1
            RANDOM => 2
            WILL_NEED => 3
            DONT_NEED => 4
            NO_REUSE => 5
      }
}

pub fn Advice::from(self : Int) -> Advice {
      match self {
            0 => NORMAL
            1 => SEQUENTIAL
            2 => RANDOM
            3 => WILL_NEED
            4 => DONT_NEED
            5 => NO_REUSE
            _ => panic()
      }
}
/// A 128-bit hash value, split into parts because wasm doesn't have a
/// 128-bit integer type.
pub(all) struct MetadataHashValue {
      lower : UInt64; upper : UInt64
} derive()
/// A descriptor is a reference to a filesystem object, which may be a file,
/// directory, named pipe, special file, or other object on which filesystem
/// calls may be made.
pub(all) struct Descriptor(Int) derive()

/// Drops a resource handle.
pub fn Descriptor::drop(self : Descriptor) -> Unit {
      let Descriptor(resource) = self
      wasmImportResourceDropDescriptor(resource)
}

fn wasmImportBytestreamNew() -> UInt64 = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-new-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamRead(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][stream-read-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamWrite(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][stream-write-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamCancelRead(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-cancel-read-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamCancelWrite(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-cancel-write-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamDropReadable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-drop-readable-0][method]descriptor.read-via-stream"
fn wasmImportBytestreamDropWritable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-drop-writable-0][method]descriptor.read-via-stream"
fn wasmBytestreamLift(ptr: Int) -> Byte {

      (@ffi.load8_u((ptr) + 0)).to_byte()
}
fn wasmBytestreamLower(value: Byte, ptr: Int) -> Unit {
      @ffi.store8((ptr) + 0, (value).to_int())

}
fn wasmBytestreamDeallocate(ptr: Int) -> Unit {

}
fn wasmBytestreamMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(1 * length);
      ptr
}
fn wasmBytestreamListLift(ptr: Int, length: Int) -> FixedArray[Byte] {
      @ffi.ptr2bytes(ptr, length)
}
fn wasmBytestreamListLower(value: FixedArray[Byte]) -> Int {
      @ffi.bytes2ptr(value)
}
fn ffi_stream_reader_byte_stream_table() -> @ffi.StreamVTable[Byte] {
      @ffi.StreamVTable::new(
      wasmImportBytestreamNew,
      wasmImportBytestreamRead,
      wasmImportBytestreamWrite,
      wasmImportBytestreamCancelRead,
      wasmImportBytestreamCancelWrite,
      wasmImportBytestreamDropReadable,
      wasmImportBytestreamDropWritable,
      wasmBytestreamMalloc,
      wasmBytestreamDeallocate,
      wasmBytestreamListLift,
      wasmBytestreamListLower,
      )
}

pub let static_ffi_stream_reader_byte_stream_table: @ffi.StreamVTable[Byte]  = ffi_stream_reader_byte_stream_table();

fn wasmImportResultUnitErrorCodefutureNew() -> UInt64 = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[future-new-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureRead(handle : Int, buffer_ptr : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][future-read-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureWrite(handle : Int, buffer_ptr : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][future-write-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureCancelRead(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[future-cancel-read-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureCancelWrite(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[future-cancel-write-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureDropReadable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[future-drop-readable-1][method]descriptor.read-via-stream"
fn wasmImportResultUnitErrorCodefutureDropWritable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[future-drop-writable-1][method]descriptor.read-via-stream"
fn wasmResultUnitErrorCodefutureLift(ptr: Int) -> Result[Unit, ErrorCode] {

      let lifted = match (@ffi.load8_u((ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((ptr) + 1)))
            }
            _ => panic()
      }

      lifted
}
fn wasmResultUnitErrorCodefutureLower(value: Result[Unit, ErrorCode], ptr: Int) -> Unit {

      match value {
            Ok(_payload) => {
                  @ffi.store8((ptr) + 0, (0))

                  ()
            }
            Err(payload2) => {
                  @ffi.store8((ptr) + 0, (1))
                  @ffi.store8((ptr) + 1, payload2.ordinal())

                  ()
            }
      }

}
fn wasmResultUnitErrorCodefutureDeallocate(ptr: Int) -> Unit {

}
fn wasmResultUnitErrorCodefutureMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(2 * length);
      ptr
}
fn wasmResultUnitErrorCodefutureListLift(ptr: Int, length: Int) -> FixedArray[Result[Unit, ErrorCode]] {

      FixedArray::makei(
      length,
      (index) => {
            let ptr = (ptr) + (index * 2);
            wasmResultUnitErrorCodefutureLift(ptr)
      }
      )

}
fn wasmResultUnitErrorCodefutureListLower(value: FixedArray[Result[Unit, ErrorCode]]) -> Int {

      let address = @ffi.malloc((value).length() * 2);
      for index = 0; index < (value).length(); index = index + 1 {
            let ptr = (address) + (index * 2);
            let value = value[index];
            wasmResultUnitErrorCodefutureLower(value, ptr);
      }
      address

}
fn ffi_future_reader_result_unit_error_code_future_table() -> @ffi.FutureVTable[Result[Unit, ErrorCode]] {
      @ffi.FutureVTable::new(
      wasmImportResultUnitErrorCodefutureNew,
      wasmImportResultUnitErrorCodefutureRead,
      wasmImportResultUnitErrorCodefutureWrite,
      wasmImportResultUnitErrorCodefutureCancelRead,
      wasmImportResultUnitErrorCodefutureCancelWrite,
      wasmImportResultUnitErrorCodefutureDropReadable,
      wasmImportResultUnitErrorCodefutureDropWritable,
      wasmResultUnitErrorCodefutureMalloc,
      wasmResultUnitErrorCodefutureDeallocate,
      wasmResultUnitErrorCodefutureLift,
      wasmResultUnitErrorCodefutureLower,
      )
}

pub let static_ffi_future_reader_result_unit_error_code_future_table: @ffi.FutureVTable[Result[Unit, ErrorCode]]  = ffi_future_reader_result_unit_error_code_future_table();

/// Return a stream for reading from a file.
///
/// Multiple read, write, and append streams may be active on the same open
/// file and they do not interfere with each other.
///
/// This function returns a `stream` which provides the data received from the
/// file, and a `future` providing additional error information in case an
/// error is encountered.
///
/// If no error is encountered, `stream.read` on the `stream` will return
/// `read-status::closed` with no `error-context` and the future resolves to
/// the value `ok`. If an error is encountered, `stream.read` on the
/// `stream` returns `read-status::closed` with an `error-context` and the future
/// resolves to `err` with an `error-code`.
///
/// Note: This is similar to `pread` in POSIX.
pub fn Descriptor::read_via_stream(self : Descriptor, offset : UInt64) -> (@ffi.StreamReader[Byte], @ffi.FutureReader[Result[Unit, ErrorCode]]) {

      let Descriptor(handle) = self
      let return_area = @ffi.malloc(8)
      wasmImportMethodDescriptorReadViaStream(handle, (offset).reinterpret_as_int64(), return_area);
      let result = @ffi.StreamReader::new(@ffi.load32((return_area) + 0), static_ffi_stream_reader_byte_stream_table);
      let result0 = @ffi.FutureReader::new(@ffi.load32((return_area) + 4), static_ffi_future_reader_result_unit_error_code_future_table);
      @ffi.free(return_area)
      return (result, result0)

}
/// Return a stream for writing to a file, if available.
///
/// May fail with an error-code describing why the file cannot be written.
///
/// It is valid to write past the end of a file; the file is extended to the
/// extent of the write, with bytes between the previous end and the start of
/// the write set to zero.
///
/// This function returns once either full contents of the stream are
/// written or an error is encountered.
///
/// Note: This is similar to `pwrite` in POSIX.
pub async fn Descriptor::write_via_stream(self : Descriptor, data : @ffi.StreamReader[Byte], offset : UInt64) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorWriteViaStream(handle, data.handle, (offset).reinterpret_as_int64(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Return a stream for appending to a file, if available.
///
/// May fail with an error-code describing why the file cannot be appended.
///
/// This function returns once either full contents of the stream are
/// written or an error is encountered.
///
/// Note: This is similar to `write` with `O_APPEND` in POSIX.
pub async fn Descriptor::append_via_stream(self : Descriptor, data : @ffi.StreamReader[Byte]) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorAppendViaStream(handle, data.handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Provide file advisory information on a descriptor.
///
/// This is similar to `posix_fadvise` in POSIX.
pub async fn Descriptor::advise(self : Descriptor, offset : UInt64, length : UInt64, advice : Advice) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorAdvise(handle, (offset).reinterpret_as_int64(), (length).reinterpret_as_int64(), advice.ordinal(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Synchronize the data of a file to disk.
///
/// This function succeeds with no effect if the file descriptor is not
/// opened for writing.
///
/// Note: This is similar to `fdatasync` in POSIX.
pub async fn Descriptor::sync_data(self : Descriptor) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSyncData(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Get flags associated with a descriptor.
///
/// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
///
/// Note: This returns the value that was the `fs_flags` value returned
/// from `fdstat_get` in earlier versions of WASI.
pub async fn Descriptor::get_flags(self : Descriptor) -> Result[DescriptorFlags, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorGetFlags(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(DescriptorFlags(@ffi.load8_u((_result_ptr) + 1).to_byte()))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Get the dynamic type of a descriptor.
///
/// Note: This returns the same value as the `type` field of the `fd-stat`
/// returned by `stat`, `stat-at` and similar.
///
/// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
/// by `fstat` in POSIX.
///
/// Note: This returns the value that was the `fs_filetype` value returned
/// from `fdstat_get` in earlier versions of WASI.
pub async fn Descriptor::get_type(self : Descriptor) -> Result[DescriptorType, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorGetType(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(DescriptorType::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Adjust the size of an open file. If this increases the file's size, the
/// extra bytes are filled with zeros.
///
/// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
pub async fn Descriptor::set_size(self : Descriptor, size : UInt64) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSetSize(handle, (size).reinterpret_as_int64(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Adjust the timestamps of an open file or directory.
///
/// Note: This is similar to `futimens` in POSIX.
///
/// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
pub async fn Descriptor::set_times(self : Descriptor, data_access_timestamp : NewTimestamp, data_modification_timestamp : NewTimestamp) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(56)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)

      match data_access_timestamp {
            NoChange => {
                  @ffi.store8((_lower_ptr + 8) + 0, (0))

                  ()
            }
            Now => {
                  @ffi.store8((_lower_ptr + 8) + 0, (1))

                  ()
            }
            Timestamp(payload5) => {
                  @ffi.store8((_lower_ptr + 8) + 0, (2))
                  @ffi.store64((_lower_ptr + 8) + 8, ((payload5).seconds).reinterpret_as_int64())
                  @ffi.store32((_lower_ptr + 8) + 16, ((payload5).nanoseconds).reinterpret_as_int())

                  ()
            }
      }

      match data_modification_timestamp {
            NoChange => {
                  @ffi.store8((_lower_ptr + 32) + 0, (0))

                  ()
            }
            Now => {
                  @ffi.store8((_lower_ptr + 32) + 0, (1))

                  ()
            }
            Timestamp(payload5) => {
                  @ffi.store8((_lower_ptr + 32) + 0, (2))
                  @ffi.store64((_lower_ptr + 32) + 8, ((payload5).seconds).reinterpret_as_int64())
                  @ffi.store32((_lower_ptr + 32) + 16, ((payload5).nanoseconds).reinterpret_as_int())

                  ()
            }
      }

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSetTimes(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}

fn wasmImportDirectoryEntrystreamNew() -> UInt64 = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-new-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamRead(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][stream-read-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamWrite(handle : Int, buffer_ptr : Int ,length : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[async-lower][stream-write-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamCancelRead(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-cancel-read-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamCancelWrite(handle : Int) -> Int = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-cancel-write-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamDropReadable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-drop-readable-0][async method]descriptor.read-directory"
fn wasmImportDirectoryEntrystreamDropWritable(handle : Int) = "wasi:filesystem/types@0.3.0-rc-2025-09-16" "[stream-drop-writable-0][async method]descriptor.read-directory"
fn wasmDirectoryEntrystreamLift(ptr: Int) -> DirectoryEntry {

      let result = @ffi.ptr2str(@ffi.load32((ptr) + 4), @ffi.load32((ptr) + 8))

      DirectoryEntry::{type_ : DescriptorType::from(@ffi.load8_u((ptr) + 0)), name : result}
}
fn wasmDirectoryEntrystreamLower(value: DirectoryEntry, ptr: Int) -> Unit {
      @ffi.store8((ptr) + 0, (value).type_.ordinal())
      @ffi.store32((ptr) + 8, (value).name.length())
      @ffi.store32((ptr) + 4, @ffi.str2ptr((value).name))

}
fn wasmDirectoryEntrystreamDeallocate(ptr: Int) -> Unit {
      @ffi.free(@ffi.load32((ptr) + 4))

}
fn wasmDirectoryEntrystreamMalloc(length: Int) -> Int {
      let ptr = @ffi.malloc(12 * length);
      ptr
}
fn wasmDirectoryEntrystreamListLift(ptr: Int, length: Int) -> FixedArray[DirectoryEntry] {

      FixedArray::makei(
      length,
      (index) => {
            let ptr = (ptr) + (index * 12);
            wasmDirectoryEntrystreamLift(ptr)
      }
      )

}
fn wasmDirectoryEntrystreamListLower(value: FixedArray[DirectoryEntry]) -> Int {

      let address = @ffi.malloc((value).length() * 12);
      for index = 0; index < (value).length(); index = index + 1 {
            let ptr = (address) + (index * 12);
            let value = value[index];
            wasmDirectoryEntrystreamLower(value, ptr);
      }
      address

}
fn ffi_stream_reader_directory_entry_stream_table() -> @ffi.StreamVTable[DirectoryEntry] {
      @ffi.StreamVTable::new(
      wasmImportDirectoryEntrystreamNew,
      wasmImportDirectoryEntrystreamRead,
      wasmImportDirectoryEntrystreamWrite,
      wasmImportDirectoryEntrystreamCancelRead,
      wasmImportDirectoryEntrystreamCancelWrite,
      wasmImportDirectoryEntrystreamDropReadable,
      wasmImportDirectoryEntrystreamDropWritable,
      wasmDirectoryEntrystreamMalloc,
      wasmDirectoryEntrystreamDeallocate,
      wasmDirectoryEntrystreamListLift,
      wasmDirectoryEntrystreamListLower,
      )
}

pub let static_ffi_stream_reader_directory_entry_stream_table: @ffi.StreamVTable[DirectoryEntry]  = ffi_stream_reader_directory_entry_stream_table();

/// Read directory entries from a directory.
///
/// On filesystems where directories contain entries referring to themselves
/// and their parents, often named `.` and `..` respectively, these entries
/// are omitted.
///
/// This always returns a new stream which starts at the beginning of the
/// directory. Multiple streams may be active on the same directory, and they
/// do not interfere with each other.
///
/// This function returns a future, which will resolve to an error code if
/// reading full contents of the directory fails.
pub async fn Descriptor::read_directory(self : Descriptor) -> (@ffi.StreamReader[DirectoryEntry], @ffi.FutureReader[Result[Unit, ErrorCode]]) {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(8 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorReadDirectory(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let result = @ffi.StreamReader::new(@ffi.load32((_result_ptr) + 0), static_ffi_stream_reader_directory_entry_stream_table);
      let result0 = @ffi.FutureReader::new(@ffi.load32((_result_ptr) + 4), static_ffi_future_reader_result_unit_error_code_future_table);

      (result, result0)

}
/// Synchronize the data and metadata of a file to disk.
///
/// This function succeeds with no effect if the file descriptor is not
/// opened for writing.
///
/// Note: This is similar to `fsync` in POSIX.
pub async fn Descriptor::sync(self : Descriptor) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSync(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Create a directory.
///
/// Note: This is similar to `mkdirat` in POSIX.
pub async fn Descriptor::create_directory_at(self : Descriptor, path : String) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorCreateDirectoryAt(handle, @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Return the attributes of an open file or directory.
///
/// Note: This is similar to `fstat` in POSIX, except that it does not return
/// device and inode information. For testing whether two descriptors refer to
/// the same underlying filesystem object, use `is-same-object`. To obtain
/// additional data that can be used do determine whether a file has been
/// modified, use `metadata-hash`.
///
/// Note: This was called `fd_filestat_get` in earlier versions of WASI.
pub async fn Descriptor::stat(self : Descriptor) -> Result[DescriptorStat, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(104 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorStat(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted16 = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  let lifted : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 32) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 40)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 48)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  let lifted8 : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 56) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 64)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 72)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  let lifted13 : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 80) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 88)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 96)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(DescriptorStat::{type_ : DescriptorType::from(@ffi.load8_u((_result_ptr) + 8)), link_count : (@ffi.load64((_result_ptr) + 16)).reinterpret_as_uint64(), size : (@ffi.load64((_result_ptr) + 24)).reinterpret_as_uint64(), data_access_timestamp : lifted, data_modification_timestamp : lifted8, status_change_timestamp : lifted13})
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 8)))
            }
            _ => panic()
      }

      lifted16

}
/// Return the attributes of a file or directory.
///
/// Note: This is similar to `fstatat` in POSIX, except that it does not
/// return device and inode information. See the `stat` description for a
/// discussion of alternatives.
///
/// Note: This was called `path_filestat_get` in earlier versions of WASI.
pub async fn Descriptor::stat_at(self : Descriptor, path_flags : PathFlags, path : String) -> Result[DescriptorStat, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let PathFlags(flag) = path_flags

      let Descriptor(handle) = self

      let PathFlags(flag) = path_flags

      let _result_ptr = @ffi.malloc(104 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorStatAt(handle, flag.to_int(), @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted16 = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  let lifted : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 32) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 40)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 48)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  let lifted8 : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 56) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 64)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 72)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  let lifted13 : @wallClock.Datetime? = match @ffi.load8_u((_result_ptr) + 80) {
                        0 => Option::None
                        1 => {

                              Option::Some(@wallClock.Datetime::{seconds : (@ffi.load64((_result_ptr) + 88)).reinterpret_as_uint64(), nanoseconds : (@ffi.load32((_result_ptr) + 96)).reinterpret_as_uint()})
                        }
                        _ => panic()
                  }

                  Result::Ok(DescriptorStat::{type_ : DescriptorType::from(@ffi.load8_u((_result_ptr) + 8)), link_count : (@ffi.load64((_result_ptr) + 16)).reinterpret_as_uint64(), size : (@ffi.load64((_result_ptr) + 24)).reinterpret_as_uint64(), data_access_timestamp : lifted, data_modification_timestamp : lifted8, status_change_timestamp : lifted13})
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 8)))
            }
            _ => panic()
      }

      lifted16

}
/// Adjust the timestamps of a file or directory.
///
/// Note: This is similar to `utimensat` in POSIX.
///
/// Note: This was called `path_filestat_set_times` in earlier versions of
/// WASI.
pub async fn Descriptor::set_times_at(self : Descriptor, path_flags : PathFlags, path : String, data_access_timestamp : NewTimestamp, data_modification_timestamp : NewTimestamp) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(64)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)

      let PathFlags(flag) = path_flags

      @ffi.store8((_lower_ptr + 4) + 0, flag.to_int())
      @ffi.store32((_lower_ptr + 8) + 4, path.length())
      @ffi.store32((_lower_ptr + 8) + 0, @ffi.str2ptr(path))

      match data_access_timestamp {
            NoChange => {
                  @ffi.store8((_lower_ptr + 16) + 0, (0))

                  ()
            }
            Now => {
                  @ffi.store8((_lower_ptr + 16) + 0, (1))

                  ()
            }
            Timestamp(payload5) => {
                  @ffi.store8((_lower_ptr + 16) + 0, (2))
                  @ffi.store64((_lower_ptr + 16) + 8, ((payload5).seconds).reinterpret_as_int64())
                  @ffi.store32((_lower_ptr + 16) + 16, ((payload5).nanoseconds).reinterpret_as_int())

                  ()
            }
      }

      match data_modification_timestamp {
            NoChange => {
                  @ffi.store8((_lower_ptr + 40) + 0, (0))

                  ()
            }
            Now => {
                  @ffi.store8((_lower_ptr + 40) + 0, (1))

                  ()
            }
            Timestamp(payload5) => {
                  @ffi.store8((_lower_ptr + 40) + 0, (2))
                  @ffi.store64((_lower_ptr + 40) + 8, ((payload5).seconds).reinterpret_as_int64())
                  @ffi.store32((_lower_ptr + 40) + 16, ((payload5).nanoseconds).reinterpret_as_int())

                  ()
            }
      }

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSetTimesAt(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Create a hard link.
///
/// Fails with `error-code::no-entry` if the old path does not exist,
/// with `error-code::exist` if the new path already exists, and
/// `error-code::not-permitted` if the old path is not a file.
///
/// Note: This is similar to `linkat` in POSIX.
pub async fn Descriptor::link_at(self : Descriptor, old_path_flags : PathFlags, old_path : String, new_descriptor : Descriptor, new_path : String) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(28)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)

      let PathFlags(flag) = old_path_flags

      @ffi.store8((_lower_ptr + 4) + 0, flag.to_int())
      @ffi.store32((_lower_ptr + 8) + 4, old_path.length())
      @ffi.store32((_lower_ptr + 8) + 0, @ffi.str2ptr(old_path))

      let Descriptor(handle) = new_descriptor
      @ffi.store32((_lower_ptr + 16) + 0, handle)
      @ffi.store32((_lower_ptr + 20) + 4, new_path.length())
      @ffi.store32((_lower_ptr + 20) + 0, @ffi.str2ptr(new_path))

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorLinkAt(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Open a file or directory.
///
/// If `flags` contains `descriptor-flags::mutate-directory`, and the base
/// descriptor doesn't have `descriptor-flags::mutate-directory` set,
/// `open-at` fails with `error-code::read-only`.
///
/// If `flags` contains `write` or `mutate-directory`, or `open-flags`
/// contains `truncate` or `create`, and the base descriptor doesn't have
/// `descriptor-flags::mutate-directory` set, `open-at` fails with
/// `error-code::read-only`.
///
/// Note: This is similar to `openat` in POSIX.
pub async fn Descriptor::open_at(self : Descriptor, path_flags : PathFlags, path : String, open_flags : OpenFlags, flags : DescriptorFlags) -> Result[Descriptor, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(20)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)

      let PathFlags(flag) = path_flags

      @ffi.store8((_lower_ptr + 4) + 0, flag.to_int())
      @ffi.store32((_lower_ptr + 8) + 4, path.length())
      @ffi.store32((_lower_ptr + 8) + 0, @ffi.str2ptr(path))

      let OpenFlags(flag) = open_flags

      @ffi.store8((_lower_ptr + 16) + 0, flag.to_int())

      let DescriptorFlags(flag) = flags

      @ffi.store8((_lower_ptr + 17) + 0, flag.to_int())

      let _result_ptr = @ffi.malloc(8 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorOpenAt(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(Descriptor::Descriptor(@ffi.load32((_result_ptr) + 4)))
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 4)))
            }
            _ => panic()
      }

      lifted

}
/// Read the contents of a symbolic link.
///
/// If the contents contain an absolute or rooted path in the underlying
/// filesystem, this function fails with `error-code::not-permitted`.
///
/// Note: This is similar to `readlinkat` in POSIX.
pub async fn Descriptor::readlink_at(self : Descriptor, path : String) -> Result[String, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(12 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorReadlinkAt(handle, @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  let result = @ffi.ptr2str(@ffi.load32((_result_ptr) + 4), @ffi.load32((_result_ptr) + 8))

                  Result::Ok(result)
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 4)))
            }
            _ => panic()
      }

      lifted

}
/// Remove a directory.
///
/// Return `error-code::not-empty` if the directory is not empty.
///
/// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
pub async fn Descriptor::remove_directory_at(self : Descriptor, path : String) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorRemoveDirectoryAt(handle, @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Rename a filesystem object.
///
/// Note: This is similar to `renameat` in POSIX.
pub async fn Descriptor::rename_at(self : Descriptor, old_path : String, new_descriptor : Descriptor, new_path : String) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(24)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)
      @ffi.store32((_lower_ptr + 4) + 4, old_path.length())
      @ffi.store32((_lower_ptr + 4) + 0, @ffi.str2ptr(old_path))

      let Descriptor(handle) = new_descriptor
      @ffi.store32((_lower_ptr + 12) + 0, handle)
      @ffi.store32((_lower_ptr + 16) + 4, new_path.length())
      @ffi.store32((_lower_ptr + 16) + 0, @ffi.str2ptr(new_path))

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorRenameAt(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Create a symbolic link (also known as a "symlink").
///
/// If `old-path` starts with `/`, the function fails with
/// `error-code::not-permitted`.
///
/// Note: This is similar to `symlinkat` in POSIX.
pub async fn Descriptor::symlink_at(self : Descriptor, old_path : String, new_path : String) -> Result[Unit, ErrorCode] {

      let _lower_ptr : Int = @ffi.malloc(20)

      let Descriptor(handle) = self
      @ffi.store32((_lower_ptr + 0) + 0, handle)
      @ffi.store32((_lower_ptr + 4) + 4, old_path.length())
      @ffi.store32((_lower_ptr + 4) + 0, @ffi.str2ptr(old_path))
      @ffi.store32((_lower_ptr + 12) + 4, new_path.length())
      @ffi.store32((_lower_ptr + 12) + 0, @ffi.str2ptr(new_path))

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorSymlinkAt(_lower_ptr, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Unlink a filesystem object that is not a directory.
///
/// Return `error-code::is-directory` if the path refers to a directory.
/// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
pub async fn Descriptor::unlink_file_at(self : Descriptor, path : String) -> Result[Unit, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(2 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorUnlinkFileAt(handle, @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(())
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 1)))
            }
            _ => panic()
      }

      lifted

}
/// Test whether two descriptors refer to the same filesystem object.
///
/// In POSIX, this corresponds to testing whether the two descriptors have the
/// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
/// wasi-filesystem does not expose device and inode numbers, so this function
/// may be used instead.
pub async fn Descriptor::is_same_object(self : Descriptor, other : Descriptor) -> Bool {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let Descriptor(handle0) = other

      let _result_ptr = @ffi.malloc(1 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorIsSameObject(handle, handle0, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      (@ffi.load8_u((_result_ptr) + 0) != 0)

}
/// Return a hash of the metadata associated with a filesystem object referred
/// to by a descriptor.
///
/// This returns a hash of the last-modification timestamp and file size, and
/// may also include the inode number, device number, birth timestamp, and
/// other metadata fields that may change when the file is modified or
/// replaced. It may also include a secret value chosen by the
/// implementation and not otherwise exposed.
///
/// Implementations are encouraged to provide the following properties:
///
///  - If the file is not modified or replaced, the computed hash value should
///    usually not change.
///  - If the object is modified or replaced, the computed hash value should
///    usually change.
///  - The inputs to the hash should not be easily computable from the
///    computed hash.
///
/// However, none of these is required.
pub async fn Descriptor::metadata_hash(self : Descriptor) -> Result[MetadataHashValue, ErrorCode] {

      let Descriptor(handle) = self

      let _result_ptr = @ffi.malloc(24 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorMetadataHash(handle, _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(MetadataHashValue::{lower : (@ffi.load64((_result_ptr) + 8)).reinterpret_as_uint64(), upper : (@ffi.load64((_result_ptr) + 16)).reinterpret_as_uint64()})
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 8)))
            }
            _ => panic()
      }

      lifted

}
/// Return a hash of the metadata associated with a filesystem object referred
/// to by a directory descriptor and a relative path.
///
/// This performs the same hash computation as `metadata-hash`.
pub async fn Descriptor::metadata_hash_at(self : Descriptor, path_flags : PathFlags, path : String) -> Result[MetadataHashValue, ErrorCode] {

      let Descriptor(handle) = self

      let Descriptor(handle) = self

      let PathFlags(flag) = path_flags

      let Descriptor(handle) = self

      let PathFlags(flag) = path_flags

      let _result_ptr = @ffi.malloc(24 * 1);

      let _subtask_code = wasmImportAsyncMethodDescriptorMetadataHashAt(handle, flag.to_int(), @ffi.str2ptr(path), path.length(), _result_ptr)
      let _subtask_status = @ffi.SubtaskStatus::decode(_subtask_code)
      let _subtask = @ffi.Subtask::from_handle(_subtask_status.handle(), code=_subtask_code)

      let task = @ffi.current_task()
      task.add_waitable(_subtask, @ffi.current_coroutine())
      defer task.remove_waitable(_subtask)

      for {
            if _subtask.done() || _subtask_status is Returned(_) {
                  break
            } else {
                  @ffi.suspend()
            }
      }

      let lifted = match (@ffi.load8_u((_result_ptr) + 0)) {
            0 => {

                  Result::Ok(MetadataHashValue::{lower : (@ffi.load64((_result_ptr) + 8)).reinterpret_as_uint64(), upper : (@ffi.load64((_result_ptr) + 16)).reinterpret_as_uint64()})
            }
            1 => {

                  Result::Err(ErrorCode::from(@ffi.load8_u((_result_ptr) + 8)))
            }
            _ => panic()
      }

      lifted

}

