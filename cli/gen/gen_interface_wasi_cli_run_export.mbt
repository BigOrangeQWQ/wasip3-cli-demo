// Generated by `wit-bindgen` 0.45.1. DO NOT EDIT!

pub fn wasmExportAsyncRun() -> Int {

      let task = @ffi.current_task();
      let _ = task.with_waitable_set(fn(task) {
            let return_result: Ref[Result[Unit, Unit]?] = Ref::new(None)
            task.wait(fn() {
                  return_result.val = Some(@run.run());
            })
            for {
                  if task.no_wait() && return_result.val is Some(return_result){
                        @run.run_task_return(return_result);
                        break;
                  } else {
                        @ffi.suspend() catch {
                              _ => {
                                    @ffi.task_cancel();
                              }
                        }
                  }
            }
      })
      if task.is_fail() is Some(@ffi.Cancelled::Cancelled) {
            @ffi.task_cancel();
            return @ffi.CallbackCode::Exit.encode()
      }
      if task.is_done() {
            return @ffi.CallbackCode::Exit.encode()
      }
      return @ffi.CallbackCode::Wait(task.handle()).encode()

}

fn _async_debug(msg: String) -> Unit {
      let task = @ffi.current_task();
      let (reader, writer) = @ffi.new_stream(
            @stdin.static_ffi_stream_reader_byte_stream_table
      )

      let hello = "\{msg}\n".to_bytes().to_fixedarray()
      task.spawn(
            fn() {
                  let n = writer.write(hello)
                  let _ = writer.drop()
            }
      )
      task.spawn(
            fn() {
                  let _ = @stdout.write_via_stream(reader)
            }
      )
}

pub fn wasmExportworldCommandAsyncAsyncRun(event_raw: Int, waitable: Int, code: Int) -> Int {
      @ffi.callback(event_raw, waitable, code)
}

